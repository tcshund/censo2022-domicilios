[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dados de Domicílios",
    "section": "",
    "text": "Este projeto processa e analisa os microdados do Censo Demográfico 2022.\n\nEstrutura\n\n01-import-data.qmd - Pipeline completo de download e conversão dos dados do IBGE\n02-indicators.qmd - Criação dos indicadores exibidos na plataforma GeoReDUS\n03-city-maps-example.qmd - Exemplos de mapas de uma cidade brasileira\ndata/ - Dados brutos e processados\nimages/ - Imagens usadas\ndocs/ - Site gerado (GitHub Pages)\n\n\n\nComo usar\n\nExecute o pipeline de importação: 01-import-data.qmd\nOs dados serão processados e organizados automaticamente (…)"
  },
  {
    "objectID": "02-indicators.html",
    "href": "02-indicators.html",
    "title": "Criação dos Indicadores",
    "section": "",
    "text": "Sobre\nEste script constrói um conjunto de indicadores relacionados ao tema Domicílios, a partir dos dados do Censo Demográfico do IBGE de 2022, para exibição na plataforma GeoReDUS. Os indicadores são calculados para todos os setores censitários do Brasil.\nOs indicadores produzidos abrangem os seguintes eixos:\n\nOcupação de Domicílios\nDados de domicílios particulares e coletivos ocupados e seus moradores.\nPosse de Domicílios\nDentre os domicílios ocupados, indicadores que abrangem os particulares permanentes e improvisados e seus moradores com recortes de sexo.\nDados de Domicílios Particulares\nDentre os domicílios particulares, recortes de tipo de residência (casas, apartamentos) e de seus moradores, além de domicílios com mais de 6 moradores.\n\nAo final, os resultados são organizados e exportados em arquivos CSV, que servem como base para análises e visualizações posteriores. Os indicadores seguem uma nomenclatura padronizada, que explicita o tema, o subtema, o recorte, a variante e o tipo de dado, permitindo a identificação direta do conteúdo de cada variável.\n\n\nBibliotecas\nLoad Packages\n\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(fs)\nlibrary(here)\nlibrary(readr)\nlibrary(tidyr)  \n\n\n\n1. Configuração do ambiente\nSet the Environment\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \npasta_pqs &lt;- sprintf(\"%s/02_processed\", pasta_base)\n\n# Criação da pasta para salvar os csvs com os indicadores\npasta_out &lt;- sprintf(\"%s/03_indicators\", pasta_base)\ndir.create(pasta_out, recursive = TRUE, showWarnings = FALSE)\n\n\n\n2. Nomenclatura adotada\n\nIndicadores de Domicílios\n\n\n\n\n\n\n\n\n\nTema\nSubtema\nST\nDescrição\nIndicador/Variável\n\n\n\n\ndom01\nOcupação\nocu\nDomicilios Ocupados\ndom01_ocu\n\n\ndom02\nPosse\ndppo\nDomicílios Particulares Permanentes Ocupados\ndom02_dppo\n\n\ndom02\nPosse\ndpio\nDomicílios Particulares Improvisados Ocupados\ndom02_dpio\n\n\ndom02\nPosse\ndccm\nDomicílios Coletivos Com Morador\ndom02_dccm\n\n\ndom03\nParticulares\ncas\nTipo de DPPO: Casas\ndom03_cas\n\n\ndom03\nParticulares\napt\nTipo de DPPO: Apartamentos\ndom03_apt\n\n\ndom03\nParticulares\n6mor\nDPPO com mais de 6 moradores\ndom03_6mor\n\n\n\n\nRecortes\n\n\nSigla\nRecorte\n\n\n\n\ntot\nTotal\n\n\ncor\nCor ou Raça\n\n\nsex\nSexo\n\n\ncorsex\nCor + Sexo\n\n\n\n\nVariantes\n\n\nSigla\nVariante\n\n\n\n\nmor\nMoradores\n\n\nf\nSexo Feminino\n\n\nm\nSexo Masculino\n\n\nama\nPessoas Amarelas\n\n\nbra\nPessoas Brancas\n\n\nind\nPessoas Indígenas\n\n\nneg\nPessoas Negras (Pretas + Pardas)\n\n\n\n\nTipo de dado\n\n\nTipo\nDescrição\n\n\n\n\n0\nDado bruto, usa diretamente a variável do IBGE (ex. V00001)\n\n\n1\nDado composto, faz soma ou subtração de variáveis do IBGE\n\n\n2\nPorcentagem (%), divide variáveis do IBGE\n\n\n\n\n\n3. Leitura dos parquets\nO fluxo deste script parte sempre dos arquivos em formato parquet, que funcionam como a fonte de dados original e nunca são modificados diretamente.\nA leitura dos parquets carrega os dados em memória como tibbles, sobre os quais aplicamos transformações com mutate(), filter(), group_by(), summarise() e outras funções do dplyr. Essas operações criam colunas temporárias, fazem cálculos e reorganizam informações, mas tudo permanece apenas no objeto resultante em memória.\nAo longo do fluxo, esses objetos transformados podem ser encadeados ou substituídos, mas não são gravados automaticamente em nenhum arquivo. Apenas na etapa final do script os resultados são efetivamentente salvos e exportados como CSVs.\n\n\n4. Criação e transformação das variáveis\nCom os dados já carregados, o script aplica operações do dplyr.\nCada linha indica uma nova coluna derivada.\nSiglas do arquivo Básico do IBGE:\n\n\n\nSigla\nDescrição\n\n\n\n\nDPPO\nDomicílio Particular Permanente Ocupado\n\n\nDPIO\nDomicílio Particular Improvisado Ocupado\n\n\nDPPV\nDomicílio Particular Permanente Vago\n\n\nDPPUO\nDomicílio Particular Permanente de Uso Ocasional\n\n\nDCCM\nDomicílio Coletivo Com Morador\n\n\nDCSM\nDomicílio Coletivo Sem Morador\n\n\nDPO\nDomicílio Particular Ocupado (DPPO + DPIO)\n\n\n\n\nbasico &lt;- read_parquet(\n  sprintf(\"%s/01_basico.parquet\", pasta_pqs)\n) %&gt;%\n  mutate(\n    across(where(is.numeric), ~replace_na(.x, 0))\n  ) %&gt;%\n  mutate(\n      # Total de Domicílios (dppo + dppv + dppuo + dpio + dccm + dcsm)\n      dom_bas_tot_0 = V0002,\n      # Total de Domicílios Particulares (dppo + dppv + dppuo + dpio)\n      dom_bas_part_0 = V0003, \n      # Total de Domicílios Coletivos (dccm + dcsm)\n      dom_bas_col_0 = V0004,\n      # Total de Domicílios Particulares Ocupados (dppo + dpio)\n      dom_bas_dpo_0 = V0007, # em tese deveria ser igual dom01_ocu_tot_1\n      # Total de Domicílios de Uso Ocasional ou Vazios (dppv + dppuo)\n      dom_bas_vaz_1 = V0003 - V0007) %&gt;%\n  mutate(\n    # # # # Indicadores Relativos\n    # Domicilios ocupados em relação os total\n    dom_bas_dpo_2 = dom_bas_dpo_0 / dom_bas_tot_0,\n    # Domicilios vazios em relação aos total\n    dom_bas_vaz_2 = dom_bas_vaz_1 / dom_bas_tot_0)\n\n\ndomicilios &lt;- read_parquet(\n  sprintf(\"%s/02_domicilio.parquet\", pasta_pqs)) %&gt;%\n  replace(is.na(.), 0) %&gt;%\n  mutate(\n      # # # Indicadores Absolutos\n      # dom01 - OCUPAÇÃO \n      # total de domicílios (dppo+dpio+dccm) \n      dom01_ocu_tot_1 = V00001 + V00002 + V00003, \n      # total de moradores (em dppo+dpio+dccm)\n      dom01_ocu_tot_mor_1 = V00005 + V00006 + V00007,\n      \n      # dom02 - PARTICULARES OCUPADOS\n      # ----- DPPO -&gt; permanentes\n      dom02_dppo_tot_0 = V00001, \n      # moradores em dppo\n      dom02_dppo_tot_mor_0 = V00005, \n      dom02_dppo_sex_m_0 = V00011,\n      dom02_dppo_sex_f_0 = V00014,\n      # ----- DPPO -&gt; improvisados\n      dom02_dpio_tot_0 = V00002, \n      \n      # dom03 - TIPOS DE DPPO\n      # Casas\n      dom03_cas_tot_1 = V00047 + V00048, \n      dom03_cas_tot_mor_1 = V00084 + V00085,\n      dom03_cas_sex_m_1 = V00502 + V00503,\n      dom03_cas_sex_f_1 = V00505 + V00506,\n      # Apartamentos\n      dom03_apt_tot_0 = V00049,\n      dom03_apt_tot_mor_0 = V00086,\n      dom03_apt_sex_m_0 = V00504,\n      dom03_apt_sex_f_0 = V00507,\n      # Domicílios com mais de 6 moradores\n      dom03_6mor_tot_1 = V00022 + V00023 + V00024 + V00025 + V00026,\n      # Domicílios com apenas 1 morador\n      dom03_1mor_tot_0 = V00017,\n      # Sem banheiro nem sanitário\n      dom03_sban_tot_0 = V00238,\n\n      # dom04 - COLETIVOS\n      # ----- DCCM -&gt; com morador\n      dom04_dccm_tot_0 = V00003,\n      # moradores em dccm\n      dom04_dccm_tot_mor_0 = V00007,\n      dom04_dccm_sex_m_0 = V00013,\n      dom04_dccm_sex_f_0 = V00016,\n      # tipos\n      dom04_dccm_asilo_0 = V00059, \n      dom04_dccm_hotel_0 = V00060, # hotel ou pensão\n      dom04_dccm_prisao_0 = V00062, # penitenciária, centro de detenção e similar\n  ) %&gt;%\n  mutate(\n    # # # Indicadores Relativos\n    # dom02 - Posse, em relação ao total de ocupados\n    dom02_dppo_tot_2 = dom02_dppo_tot_0 / dom01_ocu_tot_1,\n    dom02_dppo_tot_mor_2 = dom02_dppo_tot_mor_0 / dom01_ocu_tot_mor_1,\n    dom02_dppo_sex_f_2 = dom02_dppo_sex_f_0 / dom02_dppo_tot_mor_0,\n    dom02_dppo_sex_m_2 = dom02_dppo_sex_m_0 / dom02_dppo_tot_mor_0,  \n    dom02_dpio_tot_2 = dom02_dpio_tot_0 / dom01_ocu_tot_1,\n    \n    # dom03 - Domicílios Particulares \n    # Casas\n    dom03_cas_tot_2 = dom03_cas_tot_1 / dom02_dppo_tot_0,\n    dom03_cas_tot_mor_2 = dom03_cas_tot_mor_1 / dom02_dppo_tot_mor_0,\n    dom03_cas_sex_m_2 = dom03_cas_sex_m_1 / dom02_dppo_sex_m_0,\n    dom03_cas_sex_f_2 = dom03_cas_sex_f_1 / dom02_dppo_sex_f_0,\n    # Apartamentos\n    dom03_apt_tot_2 = dom03_apt_tot_0 / dom02_dppo_tot_0,\n    dom03_apt_tot_mor_2 = dom03_apt_tot_mor_0 / dom02_dppo_tot_mor_0,\n    dom03_apt_sex_m_2 = dom03_apt_sex_m_0 / dom02_dppo_sex_m_0,  \n    dom03_apt_sex_f_2 = dom03_apt_sex_f_0 / dom02_dppo_sex_f_0,\n    # Domicílios com mais de 6 moradores\n    dom03_6mor_tot_2 = dom03_6mor_tot_1 / dom02_dppo_tot_0    \n  ) %&gt;%\n  \n  select(matches(\"^(cd|dom)\"))\n\n\n\n5. Exportando os indicadores de Domicílio\nAs colunas criadas são unidas em novos csvs:\n\ncn22dom_vars &lt;- basico %&gt;%\n  left_join(domicilios, by = \"cd_setor\") %&gt;% \n  rename(\n    cod_setor        = cd_setor,\n    cod_bairro       = cd_bairro,\n    cod_distrito     = cd_dist,\n    cod_subdistrito  = cd_subdist,\n    cod_municipio    = cd_mun,\n    situacao_setor   = situacao,\n    cod_uf           = cd_uf,\n    nome_bairro      = nm_bairro,\n    nome_distrito    = nm_dist,\n    nome_municipio   = nm_mun,\n    nome_subdistrito = nm_subdist,\n    nome_uf          = nm_uf\n  )\n\nid_cols &lt;- c(\n  \"cod_setor\",\"cod_bairro\",\"cod_distrito\",\"cod_subdistrito\",\"cod_municipio\",\n  \"situacao_setor\",\"cod_uf\",\n  \"nome_bairro\",\"nome_distrito\",\"nome_municipio\",\"nome_subdistrito\",\"nome_uf\"\n)\n\n# Selecionar IDs + TODAS as variáveis de indicadores\ncn22dom_vars &lt;- cn22dom_vars %&gt;%\n  select(\n    all_of(id_cols),\n    matches(\"_(0|1|2)$\")\n  )\n\n# Exportar arquivo\nwrite_csv(\n  cn22dom_vars,\n  sprintf(\"%s/cn22dom_vars.csv\", pasta_out)\n)\n\n\n\n6. Verificação dos indicadores exportados\nOlhar geral no csv:\n\nglimpse(cn22dom_vars)\n\nRows: 468,099\nColumns: 58\n$ cod_setor            &lt;chr&gt; \"110001505000002\", \"110001505000003\", \"1100015050…\n$ cod_bairro           &lt;chr&gt; \"1100015006\", \"1100015006\", \"1100015005\", \"110001…\n$ cod_distrito         &lt;chr&gt; \"110001505\", \"110001505\", \"110001505\", \"110001505…\n$ cod_subdistrito      &lt;chr&gt; \"11000150500\", \"11000150500\", \"11000150500\", \"110…\n$ cod_municipio        &lt;chr&gt; \"1100015\", \"1100015\", \"1100015\", \"1100015\", \"1100…\n$ situacao_setor       &lt;chr&gt; \"Urbana\", \"Urbana\", \"Urbana\", \"Urbana\", \"Urbana\",…\n$ cod_uf               &lt;chr&gt; \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"…\n$ nome_bairro          &lt;chr&gt; \"Redondo\", \"Redondo\", \"Princesa Isabel\", \"Princes…\n$ nome_distrito        &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oeste\",…\n$ nome_municipio       &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oeste\",…\n$ nome_subdistrito     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ nome_uf              &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rondônia\", \"Rondônia\", \"…\n$ dom_bas_tot_0        &lt;dbl&gt; 376, 243, 102, 318, 334, 298, 386, 357, 131, 167,…\n$ dom_bas_part_0       &lt;dbl&gt; 376, 243, 102, 318, 334, 298, 386, 357, 131, 167,…\n$ dom_bas_col_0        &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 3, 1, 0…\n$ dom_bas_dpo_0        &lt;dbl&gt; 336, 208, 85, 282, 291, 234, 329, 291, 100, 123, …\n$ dom_bas_vaz_1        &lt;dbl&gt; 40, 35, 17, 36, 43, 64, 57, 66, 31, 44, 58, 51, 4…\n$ dom_bas_dpo_2        &lt;dbl&gt; 0.8936170, 0.8559671, 0.8333333, 0.8867925, 0.871…\n$ dom_bas_vaz_2        &lt;dbl&gt; 0.1063830, 0.1440329, 0.1666667, 0.1132075, 0.128…\n$ dom01_ocu_tot_1      &lt;dbl&gt; 336, 208, 85, 281, 291, 234, 329, 291, 100, 123, …\n$ dom01_ocu_tot_mor_1  &lt;dbl&gt; 928, 556, 222, 783, 748, 631, 884, 762, 267, 311,…\n$ dom02_dppo_tot_0     &lt;dbl&gt; 336, 208, 85, 281, 291, 234, 329, 291, 100, 123, …\n$ dom02_dppo_tot_mor_0 &lt;dbl&gt; 928, 556, 222, 783, 748, 631, 884, 762, 267, 311,…\n$ dom02_dppo_sex_m_0   &lt;dbl&gt; 428, 270, 108, 407, 373, 296, 403, 361, 141, 144,…\n$ dom02_dppo_sex_f_0   &lt;dbl&gt; 500, 286, 114, 376, 375, 335, 481, 401, 126, 167,…\n$ dom02_dpio_tot_0     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom03_cas_tot_1      &lt;dbl&gt; 335, 208, 85, 280, 291, 234, 328, 291, 100, 121, …\n$ dom03_cas_tot_mor_1  &lt;dbl&gt; 926, 556, 222, 780, 748, 631, 882, 762, 267, 308,…\n$ dom03_cas_sex_m_1    &lt;dbl&gt; 427, 270, 108, 405, 373, 296, 402, 361, 141, 142,…\n$ dom03_cas_sex_f_1    &lt;dbl&gt; 499, 286, 114, 375, 375, 335, 480, 401, 126, 166,…\n$ dom03_apt_tot_0      &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0…\n$ dom03_apt_tot_mor_0  &lt;dbl&gt; 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 7, 0, 0, 0, 0, 0, 0…\n$ dom03_apt_sex_m_0    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom03_apt_sex_f_0    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0…\n$ dom03_6mor_tot_1     &lt;dbl&gt; 8, 3, 0, 15, 0, 0, 0, 4, 0, 0, 5, 3, 3, 0, 4, 0, …\n$ dom03_1mor_tot_0     &lt;dbl&gt; 52, 39, 16, 55, 58, 31, 53, 58, 17, 24, 46, 28, 1…\n$ dom03_sban_tot_0     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_tot_0     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_tot_mor_0 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_sex_m_0   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_sex_f_0   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_asilo_0   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_hotel_0   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0…\n$ dom04_dccm_prisao_0  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom02_dppo_tot_2     &lt;dbl&gt; 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,…\n$ dom02_dppo_tot_mor_2 &lt;dbl&gt; 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.000…\n$ dom02_dppo_sex_f_2   &lt;dbl&gt; 0.5387931, 0.5143885, 0.5135135, 0.4802043, 0.501…\n$ dom02_dppo_sex_m_2   &lt;dbl&gt; 0.4612069, 0.4856115, 0.4864865, 0.5197957, 0.498…\n$ dom02_dpio_tot_2     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom03_cas_tot_2      &lt;dbl&gt; 0.9970238, 1.0000000, 1.0000000, 0.9964413, 1.000…\n$ dom03_cas_tot_mor_2  &lt;dbl&gt; 0.9978448, 1.0000000, 1.0000000, 0.9961686, 1.000…\n$ dom03_cas_sex_m_2    &lt;dbl&gt; 0.9976636, 1.0000000, 1.0000000, 0.9950860, 1.000…\n$ dom03_cas_sex_f_2    &lt;dbl&gt; 0.9980000, 1.0000000, 1.0000000, 0.9973404, 1.000…\n$ dom03_apt_tot_2      &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0…\n$ dom03_apt_tot_mor_2  &lt;dbl&gt; 0.000000000, 0.000000000, 0.000000000, 0.00383141…\n$ dom03_apt_sex_m_2    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ dom03_apt_sex_f_2    &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0…\n$ dom03_6mor_tot_2     &lt;dbl&gt; 0.02380952, 0.01442308, 0.00000000, 0.05338078, 0…\n\n\nPresença das 12 colunas de identificação do arquivo básico:\n\n\n- IDs: 12 / 12 OK\n\n\n\nIntegridade dos dados numéricos\n\n\n- Dados numéricos: AVISO: 267926 problemas encontrados \n\n\nSe houver problemas, onde estão:\n\nproblemas_tipo[ rowSums(problemas_tipo) &gt; 0, ]\n\n                     NA   NaN Inf NegInf\ndom_bas_dpo_2         0  7822   0      0\ndom_bas_vaz_2         0  7822   0      0\ndom02_dppo_tot_2      0 18011   0      0\ndom02_dppo_tot_mor_2  0 18011   0      0\ndom02_dppo_sex_f_2    0 18011   0      0\ndom02_dppo_sex_m_2    0 18011   0      0\ndom02_dpio_tot_2      0 18011   0      0\ndom03_cas_tot_2       0 18011   0      0\ndom03_cas_tot_mor_2   0 18011   0      0\ndom03_cas_sex_m_2     0 18019   0      0\ndom03_cas_sex_f_2     0 18067   0      0\ndom03_apt_tot_2       0 18011   0      0\ndom03_apt_tot_mor_2   0 18011   0      0\ndom03_apt_sex_m_2     0 18019   0      0\ndom03_apt_sex_f_2     0 18067   0      0\ndom03_6mor_tot_2      0 18011   0      0\n\n\n\n\nVerificação amostral por município\n\nmunicipio_escolhido &lt;- \"Goiânia\"\n\ncn22dom_vars %&gt;%\n  filter(nome_municipio == municipio_escolhido) %&gt;%\n  slice_sample(n = 10) %&gt;%\n  select(\n    cod_setor,\n    matches(\"dom01.*tot\")\n  ) %&gt;%\n  print(width = Inf)\n\n# A tibble: 10 × 3\n   cod_setor       dom01_ocu_tot_1 dom01_ocu_tot_mor_1\n   &lt;chr&gt;                     &lt;dbl&gt;               &lt;dbl&gt;\n 1 520870705350063             400                 995\n 2 520870705100005             347                 892\n 3 520870705510005             356                 972\n 4 520870705620005             232                 648\n 5 520870705280019             143                 504\n 6 520870705350017             262                 799\n 7 520870705380002             327                 905\n 8 520870705590013             192                 512\n 9 520870705370019             219                 581\n10 520870705260055             304                 809"
  },
  {
    "objectID": "01-import-data.html",
    "href": "01-import-data.html",
    "title": "Importação dos Dados do IBGE",
    "section": "",
    "text": "Sobre\nEste script apresenta um pipeline reproduzível para baixar, organizar, padronizar e consolidar os dados agregados referentes à dados de Domicílos do Universo do Censo Demográfico 2022 produzidos pelo Instituto Brasileiro de Geografia e Estatística - IBGE.\nO objetivo é transformar os arquivos originais, distribuídos em múltiplos conjuntos temáticos e arquivos CSV, em um conjunto integrado, limpo e eficiente de bases no formato parquet:\n\n01_basico.parquet\n02_domicilio.parquet\n\n\n\nBibliotecas\nLoad Packages\n\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(fs)\nlibrary(here)\nlibrary(httr)\nlibrary(janitor)\nlibrary(purrr)\nlibrary(readr)\nlibrary(rvest)\nlibrary(stringr)\n\n\n\nConfiguração do ambiente\nSet the Environment\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \n\npastas &lt;- c(\n  sprintf(\"%s/00_logs\", pasta_base),\n  sprintf(\"%s/01_raw\", pasta_base),\n  sprintf(\"%s/02_processed\", pasta_base)\n)\n\n# Criar pastas se ainda não existirem\nfor (pasta in pastas) {\n  dir.create(pasta, recursive = TRUE, showWarnings = FALSE)\n}\n\n# Atribuir nomes às variáveis \npasta_logs &lt;- pastas[1]  # Erros, arquivos de log\npasta_arqs &lt;- pastas[2]  # Dados brutos (zips baixados e csvs descompactados)\npasta_pqs  &lt;- pastas[3]  # Dados processados (parquets e csvs temáticos)\n\nAumentar o tempo máximo permitido para downloads:\n(padrão do R = 60s; arquivos do Censo são grandes e podem demorar mais)\n\n# getOption(\"timeout\") # Descomente para verificar o valor atual options\n(timeout = 1000) # Define novo limite (em segundos, aprox. 16 min)\n\n\n\n1. Baixar e descompactar os dados brutos\nImport\n\n1.1 Definição do link de download\nO IBGE disponibiliza os agregados por setor censitário em duas versões:\n\nXLSX: menor, mas mais lenta para carregar\nCSV: maior, porém mais leve para importar no R\n\nOptamos pela versão CSV.\n\nurl &lt;- \"https://ftp.ibge.gov.br/Censos/Censo_Demografico_2022/Agregados_por_Setores_Censitarios/Agregados_por_Setor_csv/\"\n\n\n\n1.2 Listagem dos arquivos disponíveis\n\n\n [1] \"Agregados_por_setores_alfabetizacao_BR.zip\"                      \n [2] \"Agregados_por_setores_basico_BR_20250417.zip\"                    \n [3] \"Agregados_por_setores_caracteristicas_domicilio1_BR.zip\"         \n [4] \"Agregados_por_setores_caracteristicas_domicilio2_BR_20250417.zip\"\n [5] \"Agregados_por_setores_caracteristicas_domicilio3_BR_20250417.zip\"\n [6] \"Agregados_por_setores_cor_ou_raca_BR.zip\"                        \n [7] \"Agregados_por_setores_demografia_BR.zip\"                         \n [8] \"Agregados_por_setores_domicilios_indigenas_BR.zip\"               \n [9] \"Agregados_por_setores_domicilios_quilombolas_BR.zip\"             \n[10] \"Agregados_por_setores_obitos_BR.zip\"                             \n[11] \"Agregados_por_setores_parentesco_BR.zip\"                         \n[12] \"Agregados_por_setores_pessoas_indigenas_BR.zip\"                  \n[13] \"Agregados_por_setores_pessoas_quilombolas_BR.zip\"                \n\n\nVamos selecionar apenas os arquivos “Básico” e aqueles com dados de Domicílios.\n\n\n[1] \"Agregados_por_setores_basico_BR_20250417.zip\"                    \n[2] \"Agregados_por_setores_caracteristicas_domicilio1_BR.zip\"         \n[3] \"Agregados_por_setores_caracteristicas_domicilio2_BR_20250417.zip\"\n[4] \"Agregados_por_setores_caracteristicas_domicilio3_BR_20250417.zip\"\n[5] \"Agregados_por_setores_domicilios_indigenas_BR.zip\"               \n[6] \"Agregados_por_setores_domicilios_quilombolas_BR.zip\"             \n\n\n\n\n1.3 Obter o tamanho dos arquivos a serem baixados\n\n\n179M\n\n\n\n\n1.4 Download dos arquivos\nBaixar os arquivos zips, se ainda não existirem, e salvá-los na pasta “raw”.\n\nwalk(urls, function(url) {\n  arquivo_local &lt;- file.path(pasta_arqs, basename(url))\n  \n  if (!file_exists(arquivo_local)) {\n    size_esperado &lt;- get_file_size(url)\n    resultado &lt;- try(download.file(url, arquivo_local, quiet = TRUE), silent = TRUE)\n    \n    if (inherits(resultado, \"try-error\") || \n        !file_exists(arquivo_local) || \n        (size_esperado &gt; 0 && file_size(arquivo_local) != size_esperado)) {\n      \n      cat(\"Erro no download:\", basename(url), \"\\n\")\n      \n      # Registro no log se tiver erro\n      download_error &lt;- data.frame(\n        arquivo = basename(url),\n        tipo    = \"universo_zip\",\n        stringsAsFactors = FALSE\n      )\n      \n      out_file &lt;- file.path(pasta_logs, \"erros_download_arqs.csv\")\n      write_delim(download_error, out_file, delim = \";\",\n                  append = file_exists(out_file))\n      \n      if (file_exists(arquivo_local)) file_delete(arquivo_local)\n      return()\n    }\n    cat(\"Download concluído:\", basename(url), \"\\n\")\n  } else {\n    cat(\"Arquivo já existe na pasta:\", basename(url), \"\\n\")\n  }\n})\n\n\n\n1.5 Descompactar os arquivos\nDescompactar os arquivos em formato .zip vai gerar os arquivos em .csv. O resultado é salvo na pasta “processed”.\n\nzip_files &lt;- pasta_arqs |&gt; \n        dir_ls(type = \"file\", regexp = \"\\\\.zip$\")\ncsv_files &lt;- pasta_arqs |&gt; \n        dir_ls(type = \"file\", regexp = \"\\\\.csv$\")\n\n# Se a pasta CSV já tem arquivos, pula o unzip\nif (length(csv_files) == 0) {\n  zip_files |&gt; \n        map(\\(x) unzip(x, exdir = pasta_arqs), .progress = TRUE)\n} else {\n  cat(\"Arquivos CSV já descompactados, pulando unzip...\\n\")\n}\nzip_files |&gt; file_delete() \n\n\n\n\n2. Leitura e tratamento dos dados\nTidy\nNesta etapa, os arquivos CSV descompactados são lidos, padronizados e organizados em estruturas consistentes para posterior integração.\n\n2.1 Criar função para leitura dos arquivos\nO trecho define a função abrir_csv(), que localiza todos os arquivos CSV em uma pasta usando um padrão (reg_pattern), lê todos eles como texto, concatena em um único data frame, padroniza nomes de colunas, converte para numéricas as variáveis de resultado (VXXXX), ordena pela primeira coluna (geralmente cd_setor) e devolve um objeto limpo e pronto para análise. A cada etapa, arqs_csv é atualizado, sempre substituindo o conteúdo anterior pelo novo.\n\nabrir_csv &lt;- function(reg_pattern) {\n# Localizar arquivos CSV que correspondem ao padrão informado (\"reg_pattern\")\n    arqs_csv &lt;- list.files(pasta_arqs,\n                         pattern = reg_pattern,\n                         full.names = TRUE,\n                         recursive = FALSE)   \n# Ler os CSVs como texto e transformar em df\n  arqs_csv &lt;- read_delim(arqs_csv,\n                         delim = \";\",\n                         col_types = cols(.default = \"c\"),\n                         locale = locale(encoding = \"iso_8859-1\")) %&gt;%\n    arrange(.[[1]]) # ordenar pela primeira coluna (cd_setor)\n  \n# Padronização (nomes snake_case, variáveis Vxxxx para maiúsculas (padrão oficial do IBGE)\n  arqs_csv &lt;- arqs_csv %&gt;%\n    clean_names() %&gt;%\n    rename_at(vars(matches(\"^v[0-9]{4}[0-9]?$\")), toupper) |&gt;\n    rename(cd_setor = any_of(\"setor\"))\n  \n# Tratamento especial para o arquivo \"basico\" \n  if (str_detect(reg_pattern, \"basico\")) {\n      arqs_csv &lt;- arqs_csv %&gt;%\n      mutate_at(vars\n                (matches(\"V[0-9]{3}[0-9]?$\")), \n                ~ str_replace(., ',', '.')) %&gt;%\n      mutate(area_km2 = str_replace(area_km2, ',', '.'))\n      \n    # extrair lista única de setores para uso nos parquets temáticos\n    setores &lt;- arqs_csv %&gt;% \n      select(cd_setor) %&gt;% \n      distinct()\n\n    out_file &lt;- sprintf(\"%s/00_setores.csv\", pasta_pqs) \n    write_delim(setores, out_file, delim = ';')\n  }\n  \n# Transformar valores que significam \"ausência de dado\" (X, x, . → NA)\n  arqs_csv &lt;- arqs_csv %&gt;%\n    mutate(\n        across(everything(), \n               ~ str_replace(., \"^[Xx\\\\.]$\", \n                             as.character(NA))))\n  \n# Todas as variáveis Vxxxx para numéricas\n  arqs_csv &lt;- arqs_csv %&gt;% \n    mutate_at(vars\n              (matches(\"^V[0-9]{4}[0-9]?$\")), \n              as.numeric)\n  \n  return(arqs_csv)\n}\n\n\n\n2.2 Criar função para agrupamento de arquivos temáticos\n\njuntar_temas &lt;- function(pattern_list, cod_setores) {\n  # Dataframe para agregar resultados\n  df &lt;- cod_setores\n  # para cada padrão, abrir o CSV e juntar ao df\n  for (pat in pattern_list) {\n      tmp_df &lt;- abrir_csv(pat)\n      df &lt;- left_join(df, tmp_df, by = \"cd_setor\")\n  }\n# reordenar: cd_setor primeiro, depois em ordem alfabética\n  outras &lt;- setdiff(names(df), \"cd_setor\")\n  df &lt;- df[, c(\"cd_setor\", sort(outras))]\n    \n  return(df)\n}\n\n\n\n\n3. Transformar os arquivos csvs em parquets\nTransform\nTemas: Básico e Domicílios\nPara cada grupo, faz a mesma sequência:\n\nLê os arquivos do grupo\nUsando a primeira função criada abrir_csv(\"tema\")\nOrganiza os dados por setor censitário\nUsando a segunda função criada juntar_temas().\nExporta para .parquet\nUm formato mais leve e rápido que CSV. Arquivos salvos na pasta 03_processado.\nRemove objetos da memória (rm e gc),\nNecessário porque arquivos são enormes.\n\n\n3.1 Básico\n\n# Básico\nif (!file_exists(sprintf(\"%s/01_basico.parquet\", pasta_pqs))) {\n  basico &lt;- abrir_csv(\"basico\")\n  basico &lt;- basico %&gt;% mutate(area_km2 = as.double(area_km2))\n  write_parquet(basico, sprintf(\"%s/01_basico.parquet\", pasta_pqs))\n  rm(basico); gc(T)\n  cat(\"01_basico.parquet criado\\n\")\n} else {\n  cat(\"01_basico.parquet já existe, pulando...\\n\")\n}\n\n01_basico.parquet já existe, pulando...\n\n\n\n# Exportar csv com todos os setores censitários para uso nos temas a seguir\nsetores &lt;- sprintf(\"%s/00_setores.csv\", pasta_pqs)\n\nif (file_exists(setores)) {\n  setores &lt;- read_delim(setores, delim = \";\", col_types = \"c\")\n  cat(paste0(\"CSV com setores censitários carregado (\", nrow(setores), \" setores)\\n\"))\n} else {\n  stop(\"00_setores.csv nao encontrado. Execute primeiro o bloco basico.\")\n}\n\nCSV com setores censitários carregado (468099 setores)\n\n\n\n\n3.2 Domicílios\nJunção dos cinco arquivos que contém informações sobre os domicílios.\n\n# Domicilios\nif (!file_exists(sprintf(\"%s/02_domicilio.parquet\", pasta_pqs))) {\n\n  dom_patterns &lt;- list.files(\n    pasta_arqs,\n    pattern = \"domicilio.*\\\\.csv$\",\n    full.names = FALSE\n  ) |&gt;\n    \n    str_remove(\"^Agregados_por_setores_\") |&gt;\n    str_remove(\"_BR.*\\\\.csv$\")\n\n  dom &lt;- juntar_temas(dom_patterns, cod_setores = setores)\n\n  write_parquet(dom, sprintf(\"%s/02_domicilio.parquet\", pasta_pqs))\n\n  rm(dom); gc(TRUE)\n  cat(\"02_domicilio.parquet criado\\n\")\n\n} else {\n  cat(\"02_domicilio.parquet já existe, pulando...\\n\")\n}\n\n02_domicilio.parquet já existe, pulando...\n\n\n\n\n\n4. Explorar e validar os dados\nUnderstand\n\n# Resumo dos parquets finais\npqs_files &lt;- dir_ls(pasta_pqs, regexp = \"\\\\.parquet$\")\npqs_info &lt;- map_dfr(pqs_files, ~ {\n  df &lt;- read_parquet(.x)\n  tibble(\n    arquivo = basename(.x),\n    n_setores = nrow(df), # número de setores censitários\n    n_vars = ncol(df), # número de colunas \n    tamanho_mb = file_size(.x),\n    memoria_mb = round(object.size(df) / 1024^2, 1)\n  )\n})\nprint(pqs_info)\n\n# A tibble: 2 × 5\n  arquivo              n_setores n_vars  tamanho_mb memoria_mb  \n  &lt;chr&gt;                    &lt;int&gt;  &lt;int&gt; &lt;fs::bytes&gt; &lt;objct_sz&gt;  \n1 01_basico.parquet       468099     36       11.9M 167 bytes   \n2 02_domicilio.parquet    468099   1030      144.1M 3707.1 bytes\n\n\n\nVisão geral do parquet básico\n\npqs_files |&gt; \n  keep(~ str_detect(basename(.x), \"^01_\")) |&gt;  \n  walk(~ {\n    cat(\"\\n====\", basename(.x), \"====\\n\")\n    read_parquet(.x) |&gt; \n      slice_head(n = 5) |&gt; \n      select(cd_setor, everything()) |&gt;  \n      print(n = 6)  \n  })\n\n\n==== 01_basico.parquet ====\n# A tibble: 5 × 36\n  cd_setor      situacao cd_sit cd_tipo area_km2 cd_regiao nm_regiao cd_uf nm_uf\n  &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;\n1 110001505000… Urbana   1      0          0.539 1         Norte     11    Rond…\n2 110001505000… Urbana   1      0          0.236 1         Norte     11    Rond…\n3 110001505000… Urbana   1      0          0.212 1         Norte     11    Rond…\n4 110001505000… Urbana   1      0          0.505 1         Norte     11    Rond…\n5 110001505000… Urbana   1      0          0.299 1         Norte     11    Rond…\n# ℹ 27 more variables: cd_mun &lt;chr&gt;, nm_mun &lt;chr&gt;, cd_dist &lt;chr&gt;,\n#   nm_dist &lt;chr&gt;, cd_subdist &lt;chr&gt;, nm_subdist &lt;chr&gt;, cd_bairro &lt;chr&gt;,\n#   nm_bairro &lt;chr&gt;, cd_nu &lt;chr&gt;, nm_nu &lt;chr&gt;, cd_fcu &lt;chr&gt;, nm_fcu &lt;chr&gt;,\n#   cd_aglom &lt;chr&gt;, nm_aglom &lt;chr&gt;, cd_rgint &lt;chr&gt;, nm_rgint &lt;chr&gt;,\n#   cd_rgi &lt;chr&gt;, nm_rgi &lt;chr&gt;, cd_concurb &lt;chr&gt;, nm_concurb &lt;chr&gt;,\n#   V0001 &lt;dbl&gt;, V0002 &lt;dbl&gt;, V0003 &lt;dbl&gt;, V0004 &lt;dbl&gt;, V0005 &lt;dbl&gt;,\n#   V0006 &lt;dbl&gt;, V0007 &lt;dbl&gt;\n\n\n\n\nVisão geral do parquet domicílios\n\npqs_files |&gt; \n  keep(~ str_detect(basename(.x), \"^02_\")) |&gt;  \n  walk(~ {\n    cat(\"\\n====\", basename(.x), \"====\\n\")\n    read_parquet(.x) |&gt; \n      slice_head(n = 5) |&gt; \n      select(cd_setor, everything()) |&gt;  \n      print(n = 6)  \n  })\n\n\n==== 02_domicilio.parquet ====\n# A tibble: 5 × 1,030\n  cd_setor V00001 V00002 V00003 V00004 V00005 V00006 V00007 V00008 V00009 V00010\n  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 1100015…    336      0      0    336    928      0      0    136      0      0\n2 1100015…    208      0      0    208    556      0      0     73      0      0\n3 1100015…     85      0      0     85    222      0      0     24      0      0\n4 1100015…    281     NA      0    281    783     NA      0    124      0      0\n5 1100015…    291      0      0    291    748      0      0    102      0      0\n# ℹ 1,019 more variables: V00011 &lt;dbl&gt;, V00012 &lt;dbl&gt;, V00013 &lt;dbl&gt;,\n#   V00014 &lt;dbl&gt;, V00015 &lt;dbl&gt;, V00016 &lt;dbl&gt;, V00017 &lt;dbl&gt;, V00018 &lt;dbl&gt;,\n#   V00019 &lt;dbl&gt;, V00020 &lt;dbl&gt;, V00021 &lt;dbl&gt;, V00022 &lt;dbl&gt;, V00023 &lt;dbl&gt;,\n#   V00024 &lt;dbl&gt;, V00025 &lt;dbl&gt;, V00026 &lt;dbl&gt;, V00027 &lt;dbl&gt;, V00028 &lt;dbl&gt;,\n#   V00029 &lt;dbl&gt;, V00030 &lt;dbl&gt;, V00031 &lt;dbl&gt;, V00032 &lt;dbl&gt;, V00033 &lt;dbl&gt;,\n#   V00034 &lt;dbl&gt;, V00035 &lt;dbl&gt;, V00036 &lt;dbl&gt;, V00037 &lt;dbl&gt;, V00038 &lt;dbl&gt;,\n#   V00039 &lt;dbl&gt;, V00040 &lt;dbl&gt;, V00041 &lt;dbl&gt;, V00042 &lt;dbl&gt;, V00043 &lt;dbl&gt;, …"
  },
  {
    "objectID": "03-city-maps-example.html",
    "href": "03-city-maps-example.html",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "Código IBGE do município: 3550308\nAno de referência: 2022\nFonte: IBGE - Censo Demográfico 2022\nEste documento gera mapas interativos dos indicadores domiciliares do Censo 2022 para o município de São Paulo. Os dados são visualizados por setor censitário, permitindo análises detalhadas intraurbanas.\n\n\n\nlibrary(dplyr)\nlibrary(readr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(geobr)\nlibrary(stringr)\nlibrary(viridis)\nlibrary(leaflet)\nlibrary(scales)\nlibrary(here)\nlibrary(DT)\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \npasta_out &lt;- sprintf(\"%s/03_indicators\", pasta_base)\npasta_shapes &lt;- sprintf(\"%s/04_shapes\", pasta_base)\n\ncn22dom_vars &lt;- read_csv(\n  file.path(pasta_out, \"cn22dom_vars.csv\"),\n  show_col_types = FALSE\n)\n\n# glimpse(cn22dom_vars)\n\n\n# Definição do município\ncod_mun  &lt;- \"3550308\"\nnome_mun &lt;- \"São Paulo\"\n\nstopifnot(cod_mun %in% cn22dom_vars$cod_municipio)\n\n# Preparar base de indicadores\nindicadores &lt;- cn22dom_vars %&gt;%\n  mutate(\n    cod_setor = as.character(cod_setor),\n    cod_municipio = as.character(cod_municipio)\n  )\n\ncat(\n  \"Indicadores carregados (absolutos e relativos): \",\n  nrow(indicadores),\n  \" setores\\n\",\n  sep = \"\"\n)\n\nIndicadores carregados (absolutos e relativos): 468099 setores\n\n# Filtrar para o município\nindicadores_mun &lt;- indicadores %&gt;%\n  filter(cod_municipio == cod_mun) %&gt;%\n  mutate(cod_setor_ibge = cod_setor)\n\ncat(\n  \"Setores em \",\n  nome_mun,\n  \": \",\n  nrow(indicadores_mun),\n  \"\\n\\n\",\n  sep = \"\"\n)\n\nSetores em São Paulo: 27301\n\n# Verificação final\nif (nrow(indicadores_mun) == 0) {\n  stop(\"Nenhum setor encontrado para \", nome_mun)\n}\n\ncat(\"Primeiro setor: \", indicadores_mun$cod_setor[1], \"\\n\", sep = \"\")\n\nPrimeiro setor: 355030801000001\n\ncat(\"Exemplo de indicador disponível:\\n\")\n\nExemplo de indicador disponível:\n\nvars_cn22 &lt;- names(indicadores_mun)[str_detect(names(indicadores_mun), \"^cn22_\")]\nprint(head(vars_cn22, 1))\n\n[1] \"cn22_dom01_ocu_tot_1\"\n\n\n\n\n\n\n# Nome do arquivo shape para este município\nshape_file &lt;- file.path(pasta_shapes, paste0(\"setores_\", cod_mun, \".gpkg\"))\n\nif (!file.exists(shape_file)) {\n  cat(\"Baixando shapes dos setores censitários...\\n\")\n  \n  # URL base dos shapes do IBGE (BC250 - versão mais recente)\n  # Para 2022, usar a base de 2019 que é compatível\n  base_url &lt;- \"https://geoftp.ibge.gov.br/cartas_e_mapas/bases_cartograficas_continuas/bc250/versao2023/geopackage/\"\n  \n  # Determinar UF a partir do código do município\n  uf_code &lt;- substr(cod_mun, 1, 2)\n  \n  # Mapeamento código UF para sigla\n  uf_siglas &lt;- c(\n    \"11\" = \"RO\", \"12\" = \"AC\", \"13\" = \"AM\", \"14\" = \"RR\", \"15\" = \"PA\",\n    \"16\" = \"AP\", \"17\" = \"TO\", \"21\" = \"MA\", \"22\" = \"PI\", \"23\" = \"CE\",\n    \"24\" = \"RN\", \"25\" = \"PB\", \"26\" = \"PE\", \"27\" = \"AL\", \"28\" = \"SE\",\n    \"29\" = \"BA\", \"31\" = \"MG\", \"32\" = \"ES\", \"33\" = \"RJ\", \"35\" = \"SP\",\n    \"41\" = \"PR\", \"42\" = \"SC\", \"43\" = \"RS\", \"50\" = \"MS\", \"51\" = \"MT\",\n    \"52\" = \"GO\", \"53\" = \"DF\"\n  )\n  \n  uf_sigla &lt;- uf_siglas[uf_code]\n  \n  if (is.na(uf_sigla)) {\n    stop(\"Código UF inválido: \", uf_code)\n  }\n  \n  # URL alternativa: usar geobr para download simplificado\n  cat(\"Usando pacote geobr para download dos shapes...\\n\")\n  \n  # Instalar geobr se necessário\n  if (!requireNamespace(\"geobr\", quietly = TRUE)) {\n    install.packages(\"geobr\")\n  }\n  library(geobr)\n  \n  # Baixar shapes dos setores censitários\n  tryCatch({\n    setores_sf &lt;- read_census_tract(\n      year = 2019,  # Último ano disponível compatível com 2022\n      code_tract = \"all\",\n      simplified = TRUE\n    )\n    \n    # Filtrar para o município\n    setores_mun &lt;- setores_sf %&gt;%\n      filter(code_muni == as.numeric(cod_mun))\n    \n    # Salvar em arquivo local para cache\n    st_write(setores_mun, shape_file, quiet = TRUE)\n    cat(\"Shapes salvos em:\", shape_file, \"\\n\")\n    \n  }, error = function(e) {\n    cat(\"Erro ao baixar via geobr:\", e$message, \"\\n\")\n    cat(\"Usando shapes locais se disponíveis...\\n\")\n  })\n}\n\n# Carregar shapes\nif (file.exists(shape_file)) {\n  setores_sf &lt;- st_read(shape_file, quiet = TRUE)\n} else {\n  # Fallback: criar geometria simplificada a partir dos centroides\n  cat(\"Criando geometria aproximada a partir de coordenadas...\\n\")\n  \n  # Se você tiver coordenadas dos setores, carregue aqui\n  # Por enquanto, criamos pontos aleatórios para demonstração\n  set.seed(123)\n  setores_sf &lt;- indicadores_mun %&gt;%\n    mutate(\n      geometry = st_sfc(\n        lapply(1:n(), function(i) {\n          # Coordenadas aproximadas do município\n          # Em produção, use coordenadas reais!\n          lon &lt;- -46.6 + runif(1, -0.2, 0.2)\n          lat &lt;- -23.5 + runif(1, -0.2, 0.2)\n          st_point(c(lon, lat))\n        })\n      )\n    ) %&gt;%\n    st_as_sf()\n}\n\ncat(\"Shapes carregados:\", nrow(setores_sf), \"setores\\n\")\n\nShapes carregados: 27149 setores\n\n\n\n\n\n\n# Converter código do setor para formato compatível\nsetores_com_dados &lt;- setores_sf %&gt;%\n  mutate(\n    code_tract_char = as.character(code_tract)\n  ) %&gt;%\n  left_join(\n    indicadores_mun,\n    by = c(\"code_tract_char\" = \"cod_setor_ibge\")\n  )\n\n# Verificar junção\nsetores_com_info &lt;- setores_com_dados %&gt;%\n  filter(!is.na(cn22_dom03_cas_tot_2))\n\ncat(\"Setores com dados e geometria:\", nrow(setores_com_info), \n    \"(\", round(nrow(setores_com_info)/nrow(indicadores_mun)*100, 1), \"%)\\n\")\n\nSetores com dados e geometria: 24908 ( 91.2 %)\n\n\n\n\n\n\n# Preparar dados para o mapa\ndados_mapa &lt;- setores_com_info %&gt;%\n  mutate(\n    prop_casas = cn22_dom03_cas_tot_2 * 100,\n    prop_aptos = cn22_dom03_apt_tot_2 * 100,\n    densidade = cn22_dom03_6mor_tot_2 * 100\n  )\n\n# Função para criar paleta de cores\ncriar_paleta &lt;- function(variavel, cores = \"YlOrRd\", reversa = FALSE) {\n  colorNumeric(\n    palette = cores,\n    domain = variavel,\n    na.color = \"#808080\",\n    reverse = reversa\n  )\n}\n\n# Paleta para proporção de casas\npal_casas &lt;- criar_paleta(dados_mapa$prop_casas, \"YlOrRd\")\n\n# Criar mapa Leaflet\nmapa_casas &lt;- leaflet(dados_mapa) %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  addPolygons(\n    fillColor = ~pal_casas(prop_casas),\n    fillOpacity = 0.7,\n    color = \"#444444\",\n    weight = 0.5,\n    smoothFactor = 0.5,\n    label = ~paste(\n      \"Setor:\", code_tract_char,\n      \"&lt;br&gt;Casas:\", round(prop_casas, 1), \"%\",\n      \"&lt;br&gt;Aptos:\", round(prop_aptos, 1), \"%\",\n      \"&lt;br&gt;Densidade (&gt;6 moradores):\", round(densidade, 1), \"%\"\n    ) %&gt;% lapply(htmltools::HTML),\n    highlightOptions = highlightOptions(\n      weight = 2,\n      color = \"#666666\",\n      bringToFront = TRUE\n    )\n  ) %&gt;%\n  addLegend(\n    pal = pal_casas,\n    values = ~prop_casas,\n    opacity = 0.7,\n    title = \"% de Casas\",\n    position = \"bottomright\",\n    labFormat = labelFormat(suffix = \"%\")\n  ) %&gt;%\n  addControl(\n    paste(nome_mun, \"- Proporção de Domicílios tipo Casa\"),\n    position = \"topright\"\n  )\n\nmapa_casas\n\n\n\n\n\n\n\n\n\n# Filtrar setores com dados de improvisados\ndados_improvisados &lt;- dados_mapa %&gt;%\n  mutate(\n    prop_improvisados = cn22_dom02_dpio_tot_2 * 100\n  ) %&gt;%\n  filter(!is.na(prop_improvisados) & prop_improvisados &gt; 0)\n\n# Paleta para improvisados (vermelho = mais crítico)\npal_improvisados &lt;- criar_paleta(dados_improvisados$prop_improvisados, \"Reds\")\n\n# Criar mapa\nmapa_improvisados &lt;- leaflet(dados_improvisados) %&gt;%\n  addProviderTiles(\"CartoDB.DarkMatter\") %&gt;%\n  addPolygons(\n    fillColor = ~pal_improvisados(prop_improvisados),\n    fillOpacity = 0.8,\n    color = \"#222222\",\n    weight = 0.3,\n    label = ~paste(\n      \"Setor:\", code_tract_char,\n      \"&lt;br&gt;Domic. improvisados:\", round(prop_improvisados, 2), \"%\",\n      \"&lt;br&gt;Total domicílios:\", cn22_dom01_ocu_tot_1\n    ) %&gt;% lapply(htmltools::HTML)\n  ) %&gt;%\n  addLegend(\n    pal = pal_improvisados,\n    values = ~prop_improvisados,\n    opacity = 0.8,\n    title = \"% Improvisados\",\n    position = \"bottomright\",\n    labFormat = labelFormat(suffix = \"%\", digits = 2)\n  ) %&gt;%\n  addControl(\n    paste(nome_mun, \"- Domicílios Improvisados\"),\n    position = \"topright\"\n  )\n\nmapa_improvisados\n\n\n\n\n\n\n\n\n\n# Criar mapas estáticos com ggplot2\nif (all(st_geometry_type(dados_mapa) %in% c(\"POLYGON\", \"MULTIPOLYGON\"))) {\n  # Mapa 1: Proporção de casas\n  mapa_estatico1 &lt;- ggplot(dados_mapa) +\n    geom_sf(aes(fill = prop_casas), color = NA, size = 0.1) +\n    scale_fill_viridis(\n      name = \"% Casas\",\n      option = \"plasma\",\n      na.value = \"gray90\",\n      labels = scales::percent_format(scale = 1)\n    ) +\n    labs(\n      title = paste(\"Proporção de Domicílios tipo Casa -\", nome_mun),\n      subtitle = \"Por setor censitário - Censo 2022\",\n      caption = \"Fonte: IBGE - Censo Demográfico 2022\"\n    ) +\n    theme_void() +\n    theme(\n      plot.title = element_text(hjust = 0.5, face = \"bold\", size = 14),\n      legend.position = \"bottom\",\n      legend.key.width = unit(2, \"cm\")\n    )\n  \n  print(mapa_estatico1)\n  \n  # Mapa 2: Domicílios improvisados\n  if (nrow(dados_improvisados) &gt; 0) {\n    mapa_estatico2 &lt;- ggplot(dados_improvisados) +\n      geom_sf(aes(fill = prop_improvisados), color = NA, size = 0.1) +\n      scale_fill_gradientn(\n        name = \"% Improvisados\",\n        colors = c(\"lightyellow\", \"orange\", \"red\", \"darkred\"),\n        na.value = \"gray90\",\n        limits = c(0, max(dados_improvisados$prop_improvisados, na.rm = TRUE)),\n        labels = scales::percent_format(scale = 1, accuracy = 0.1)\n      ) +\n      labs(\n        title = paste(\"Domicílios Improvisados -\", nome_mun),\n        subtitle = \"Por setor censitário - Censo 2022\",\n        caption = \"Fonte: IBGE - Censo Demográfico 2022\"\n      ) +\n      theme_void() +\n      theme(\n        plot.title = element_text(hjust = 0.5, face = \"bold\", size = 14),\n        legend.position = \"bottom\",\n        legend.key.width = unit(2, \"cm\")\n      )\n    \n    print(mapa_estatico2)\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Agregar indicadores por bairro (se disponível)\nif (\"nome_bairro\" %in% names(indicadores_mun)) {\n  bairros_agg &lt;- indicadores_mun %&gt;%\n    group_by(cod_bairro, nome_bairro) %&gt;%\n    summarise(\n      n_setores = n(),\n      media_casas = mean(cn22_dom03_cas_tot_2 * 100, na.rm = TRUE),\n      media_aptos = mean(cn22_dom03_apt_tot_2 * 100, na.rm = TRUE),\n      media_improvisados = mean(cn22_dom02_dpio_tot_2 * 100, na.rm = TRUE),\n      media_densidade = mean(cn22_dom03_6mor_tot_2 * 100, na.rm = TRUE),\n      .groups = 'drop'\n    ) %&gt;%\n    arrange(desc(media_improvisados))\n  \n  # Gráfico de ranking\n  top_bairros &lt;- bairros_agg %&gt;%\n    filter(!is.na(nome_bairro) & nome_bairro != \"\") %&gt;%\n    arrange(desc(media_improvisados)) %&gt;%\n    head(15)\n  \n  if (nrow(top_bairros) &gt; 0) {\n    ggplot(top_bairros, \n           aes(x = reorder(nome_bairro, media_improvisados), \n               y = media_improvisados)) +\n      geom_col(fill = \"steelblue\", alpha = 0.8) +\n      geom_text(aes(label = round(media_improvisados, 2)), \n                hjust = -0.2, size = 3) +\n      coord_flip() +\n      labs(\n        title = paste(\"Top 15 Bairros com Mais Domicílios Improvisados -\", nome_mun),\n        x = \"Bairro\",\n        y = \"% de Domicílios Improvisados\"\n      ) +\n      theme_minimal() +\n      theme(\n        plot.title = element_text(face = \"bold\"),\n        axis.text.y = element_text(size = 9)\n      )\n  }\n}\n\n\n\n\n\n# Criar tabela resumo para os primeiros 50 setores\ntabela_resumo &lt;- setores_com_info %&gt;%\n  st_drop_geometry() %&gt;%\n  select(\n    Setor = code_tract_char,\n    Bairro = nome_bairro,\n    `Casas (%)` = cn22_dom03_cas_tot_2,\n    `Aptos (%)` = cn22_dom03_apt_tot_2,\n    `Improvisados (%)` = cn22_dom02_dpio_tot_2,\n    `&gt;6 Moradores (%)` = cn22_dom03_6mor_tot_2,\n    `Total Domicílios` = cn22_dom01_ocu_tot_1\n  ) %&gt;%\n  mutate(\n    across(where(is.numeric) & contains(\"%\"), ~ round(.x * 100, 2)),\n    across(where(is.numeric) & !contains(\"%\"), ~ round(.x, 0))\n  ) %&gt;%\n  head(50)  # Limitar para performance\n\n# Tabela interativa com DT\ndatatable(\n  tabela_resumo,\n  options = list(\n    pageLength = 10,\n    dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel'),\n    scrollX = TRUE\n  ),\n  caption = paste(\"Indicadores Domiciliares - Primeiros 50 Setores -\", nome_mun),\n  rownames = FALSE,\n  filter = 'top'\n) %&gt;%\n  formatStyle(\n    'Improvisados (%)',\n    background = styleColorBar(tabela_resumo$`Improvisados (%)`, 'lightcoral'),\n    backgroundSize = '100% 90%',\n    backgroundRepeat = 'no-repeat'\n  ) %&gt;%\n  formatStyle(\n    'Casas (%)',\n    background = styleColorBar(tabela_resumo$`Casas (%)`, 'lightblue'),\n    backgroundSize = '100% 90%'\n  )\n\n\n\n\n\n\n\n\n\n# Calcular estatísticas descritivas\nresumo_estatistico &lt;- indicadores_mun %&gt;%\n  summarise(\n    `Total Setores` = n(),\n    `Média Casas (%)` = mean(cn22_dom03_cas_tot_2 * 100, na.rm = TRUE),\n    `Média Aptos (%)` = mean(cn22_dom03_apt_tot_2 * 100, na.rm = TRUE),\n    `Média Improvisados (%)` = mean(cn22_dom02_dpio_tot_2 * 100, na.rm = TRUE),\n    `Média &gt;6 Moradores (%)` = mean(cn22_dom03_6mor_tot_2 * 100, na.rm = TRUE),\n    `Total Domicílios` = sum(cn22_dom01_ocu_tot_1, na.rm = TRUE),\n    `Total Moradores` = sum(cn22_dom01_ocu_tot_mor_1, na.rm = TRUE)\n  ) %&gt;%\n  mutate(across(where(is.numeric), ~ round(.x, 2)))\n\ncat(\"RESUMO ESTATÍSTICO -\", nome_mun, \"\\n\")\n\nRESUMO ESTATÍSTICO - São Paulo \n\ncat(\"================================\\n\")\n\n================================\n\nprint(resumo_estatistico)\n\n# A tibble: 1 × 7\n  `Total Setores` `Média Casas (%)` `Média Aptos (%)` `Média Improvisados (%)`\n            &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;                    &lt;dbl&gt;\n1           27301              63.6              35.4                     0.14\n# ℹ 3 more variables: `Média &gt;6 Moradores (%)` &lt;dbl&gt;, `Total Domicílios` &lt;dbl&gt;,\n#   `Total Moradores` &lt;dbl&gt;\n\n\n\n\n\nPara gerar mapas para outro município, renderize com parâmetros diferentes:\n# Rio de Janeiro\nquarto render 03-mapa-cidades.qmd -P cod_mun:3304557 -P nome_mun:\"Rio de Janeiro\"\n\n# Belo Horizonte\nquarto render 03-mapa-cidades.qmd -P cod_mun:3106200 -P nome_mun:\"Belo Horizonte\"\n\n# Curitiba\nquarto render 03-mapa-cidades.qmd -P cod_mun:4106902 -P nome_mun:\"Curitiba\"\nPróximos passos: 1. Execute 01-import-data.qmd para baixar os dados 2. Execute 02-gerar-indicadores.qmd para calcular indicadores\n3. Execute este documento para gerar os mapas 4. Para publicar: quarto render e suba a pasta docs/ para GitHub Pages\n\nDocumento gerado em 07/01/2026 19:31"
  },
  {
    "objectID": "03-city-maps-example.html#configuração-do-ambiente",
    "href": "03-city-maps-example.html#configuração-do-ambiente",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "library(dplyr)\nlibrary(readr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(geobr)\nlibrary(stringr)\nlibrary(viridis)\nlibrary(leaflet)\nlibrary(scales)\nlibrary(here)\nlibrary(DT)\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \npasta_out &lt;- sprintf(\"%s/03_indicators\", pasta_base)\npasta_shapes &lt;- sprintf(\"%s/04_shapes\", pasta_base)\n\ncn22dom_vars &lt;- read_csv(\n  file.path(pasta_out, \"cn22dom_vars.csv\"),\n  show_col_types = FALSE\n)\n\n# glimpse(cn22dom_vars)\n\n\n# Definição do município\ncod_mun  &lt;- \"3550308\"\nnome_mun &lt;- \"São Paulo\"\n\nstopifnot(cod_mun %in% cn22dom_vars$cod_municipio)\n\n# Preparar base de indicadores\nindicadores &lt;- cn22dom_vars %&gt;%\n  mutate(\n    cod_setor = as.character(cod_setor),\n    cod_municipio = as.character(cod_municipio)\n  )\n\ncat(\n  \"Indicadores carregados (absolutos e relativos): \",\n  nrow(indicadores),\n  \" setores\\n\",\n  sep = \"\"\n)\n\nIndicadores carregados (absolutos e relativos): 468099 setores\n\n# Filtrar para o município\nindicadores_mun &lt;- indicadores %&gt;%\n  filter(cod_municipio == cod_mun) %&gt;%\n  mutate(cod_setor_ibge = cod_setor)\n\ncat(\n  \"Setores em \",\n  nome_mun,\n  \": \",\n  nrow(indicadores_mun),\n  \"\\n\\n\",\n  sep = \"\"\n)\n\nSetores em São Paulo: 27301\n\n# Verificação final\nif (nrow(indicadores_mun) == 0) {\n  stop(\"Nenhum setor encontrado para \", nome_mun)\n}\n\ncat(\"Primeiro setor: \", indicadores_mun$cod_setor[1], \"\\n\", sep = \"\")\n\nPrimeiro setor: 355030801000001\n\ncat(\"Exemplo de indicador disponível:\\n\")\n\nExemplo de indicador disponível:\n\nvars_cn22 &lt;- names(indicadores_mun)[str_detect(names(indicadores_mun), \"^cn22_\")]\nprint(head(vars_cn22, 1))\n\n[1] \"cn22_dom01_ocu_tot_1\""
  },
  {
    "objectID": "03-city-maps-example.html#baixar-e-preparar-shapes-dos-setores-censitários",
    "href": "03-city-maps-example.html#baixar-e-preparar-shapes-dos-setores-censitários",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Nome do arquivo shape para este município\nshape_file &lt;- file.path(pasta_shapes, paste0(\"setores_\", cod_mun, \".gpkg\"))\n\nif (!file.exists(shape_file)) {\n  cat(\"Baixando shapes dos setores censitários...\\n\")\n  \n  # URL base dos shapes do IBGE (BC250 - versão mais recente)\n  # Para 2022, usar a base de 2019 que é compatível\n  base_url &lt;- \"https://geoftp.ibge.gov.br/cartas_e_mapas/bases_cartograficas_continuas/bc250/versao2023/geopackage/\"\n  \n  # Determinar UF a partir do código do município\n  uf_code &lt;- substr(cod_mun, 1, 2)\n  \n  # Mapeamento código UF para sigla\n  uf_siglas &lt;- c(\n    \"11\" = \"RO\", \"12\" = \"AC\", \"13\" = \"AM\", \"14\" = \"RR\", \"15\" = \"PA\",\n    \"16\" = \"AP\", \"17\" = \"TO\", \"21\" = \"MA\", \"22\" = \"PI\", \"23\" = \"CE\",\n    \"24\" = \"RN\", \"25\" = \"PB\", \"26\" = \"PE\", \"27\" = \"AL\", \"28\" = \"SE\",\n    \"29\" = \"BA\", \"31\" = \"MG\", \"32\" = \"ES\", \"33\" = \"RJ\", \"35\" = \"SP\",\n    \"41\" = \"PR\", \"42\" = \"SC\", \"43\" = \"RS\", \"50\" = \"MS\", \"51\" = \"MT\",\n    \"52\" = \"GO\", \"53\" = \"DF\"\n  )\n  \n  uf_sigla &lt;- uf_siglas[uf_code]\n  \n  if (is.na(uf_sigla)) {\n    stop(\"Código UF inválido: \", uf_code)\n  }\n  \n  # URL alternativa: usar geobr para download simplificado\n  cat(\"Usando pacote geobr para download dos shapes...\\n\")\n  \n  # Instalar geobr se necessário\n  if (!requireNamespace(\"geobr\", quietly = TRUE)) {\n    install.packages(\"geobr\")\n  }\n  library(geobr)\n  \n  # Baixar shapes dos setores censitários\n  tryCatch({\n    setores_sf &lt;- read_census_tract(\n      year = 2019,  # Último ano disponível compatível com 2022\n      code_tract = \"all\",\n      simplified = TRUE\n    )\n    \n    # Filtrar para o município\n    setores_mun &lt;- setores_sf %&gt;%\n      filter(code_muni == as.numeric(cod_mun))\n    \n    # Salvar em arquivo local para cache\n    st_write(setores_mun, shape_file, quiet = TRUE)\n    cat(\"Shapes salvos em:\", shape_file, \"\\n\")\n    \n  }, error = function(e) {\n    cat(\"Erro ao baixar via geobr:\", e$message, \"\\n\")\n    cat(\"Usando shapes locais se disponíveis...\\n\")\n  })\n}\n\n# Carregar shapes\nif (file.exists(shape_file)) {\n  setores_sf &lt;- st_read(shape_file, quiet = TRUE)\n} else {\n  # Fallback: criar geometria simplificada a partir dos centroides\n  cat(\"Criando geometria aproximada a partir de coordenadas...\\n\")\n  \n  # Se você tiver coordenadas dos setores, carregue aqui\n  # Por enquanto, criamos pontos aleatórios para demonstração\n  set.seed(123)\n  setores_sf &lt;- indicadores_mun %&gt;%\n    mutate(\n      geometry = st_sfc(\n        lapply(1:n(), function(i) {\n          # Coordenadas aproximadas do município\n          # Em produção, use coordenadas reais!\n          lon &lt;- -46.6 + runif(1, -0.2, 0.2)\n          lat &lt;- -23.5 + runif(1, -0.2, 0.2)\n          st_point(c(lon, lat))\n        })\n      )\n    ) %&gt;%\n    st_as_sf()\n}\n\ncat(\"Shapes carregados:\", nrow(setores_sf), \"setores\\n\")\n\nShapes carregados: 27149 setores"
  },
  {
    "objectID": "03-city-maps-example.html#juntar-dados-e-geometrias",
    "href": "03-city-maps-example.html#juntar-dados-e-geometrias",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Converter código do setor para formato compatível\nsetores_com_dados &lt;- setores_sf %&gt;%\n  mutate(\n    code_tract_char = as.character(code_tract)\n  ) %&gt;%\n  left_join(\n    indicadores_mun,\n    by = c(\"code_tract_char\" = \"cod_setor_ibge\")\n  )\n\n# Verificar junção\nsetores_com_info &lt;- setores_com_dados %&gt;%\n  filter(!is.na(cn22_dom03_cas_tot_2))\n\ncat(\"Setores com dados e geometria:\", nrow(setores_com_info), \n    \"(\", round(nrow(setores_com_info)/nrow(indicadores_mun)*100, 1), \"%)\\n\")\n\nSetores com dados e geometria: 24908 ( 91.2 %)"
  },
  {
    "objectID": "03-city-maps-example.html#mapa-interativo-1-proporção-de-casas-x-apartamentos",
    "href": "03-city-maps-example.html#mapa-interativo-1-proporção-de-casas-x-apartamentos",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Preparar dados para o mapa\ndados_mapa &lt;- setores_com_info %&gt;%\n  mutate(\n    prop_casas = cn22_dom03_cas_tot_2 * 100,\n    prop_aptos = cn22_dom03_apt_tot_2 * 100,\n    densidade = cn22_dom03_6mor_tot_2 * 100\n  )\n\n# Função para criar paleta de cores\ncriar_paleta &lt;- function(variavel, cores = \"YlOrRd\", reversa = FALSE) {\n  colorNumeric(\n    palette = cores,\n    domain = variavel,\n    na.color = \"#808080\",\n    reverse = reversa\n  )\n}\n\n# Paleta para proporção de casas\npal_casas &lt;- criar_paleta(dados_mapa$prop_casas, \"YlOrRd\")\n\n# Criar mapa Leaflet\nmapa_casas &lt;- leaflet(dados_mapa) %&gt;%\n  addProviderTiles(\"CartoDB.Positron\") %&gt;%\n  addPolygons(\n    fillColor = ~pal_casas(prop_casas),\n    fillOpacity = 0.7,\n    color = \"#444444\",\n    weight = 0.5,\n    smoothFactor = 0.5,\n    label = ~paste(\n      \"Setor:\", code_tract_char,\n      \"&lt;br&gt;Casas:\", round(prop_casas, 1), \"%\",\n      \"&lt;br&gt;Aptos:\", round(prop_aptos, 1), \"%\",\n      \"&lt;br&gt;Densidade (&gt;6 moradores):\", round(densidade, 1), \"%\"\n    ) %&gt;% lapply(htmltools::HTML),\n    highlightOptions = highlightOptions(\n      weight = 2,\n      color = \"#666666\",\n      bringToFront = TRUE\n    )\n  ) %&gt;%\n  addLegend(\n    pal = pal_casas,\n    values = ~prop_casas,\n    opacity = 0.7,\n    title = \"% de Casas\",\n    position = \"bottomright\",\n    labFormat = labelFormat(suffix = \"%\")\n  ) %&gt;%\n  addControl(\n    paste(nome_mun, \"- Proporção de Domicílios tipo Casa\"),\n    position = \"topright\"\n  )\n\nmapa_casas"
  },
  {
    "objectID": "03-city-maps-example.html#mapa-interativo-2-domicílios-improvisados",
    "href": "03-city-maps-example.html#mapa-interativo-2-domicílios-improvisados",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Filtrar setores com dados de improvisados\ndados_improvisados &lt;- dados_mapa %&gt;%\n  mutate(\n    prop_improvisados = cn22_dom02_dpio_tot_2 * 100\n  ) %&gt;%\n  filter(!is.na(prop_improvisados) & prop_improvisados &gt; 0)\n\n# Paleta para improvisados (vermelho = mais crítico)\npal_improvisados &lt;- criar_paleta(dados_improvisados$prop_improvisados, \"Reds\")\n\n# Criar mapa\nmapa_improvisados &lt;- leaflet(dados_improvisados) %&gt;%\n  addProviderTiles(\"CartoDB.DarkMatter\") %&gt;%\n  addPolygons(\n    fillColor = ~pal_improvisados(prop_improvisados),\n    fillOpacity = 0.8,\n    color = \"#222222\",\n    weight = 0.3,\n    label = ~paste(\n      \"Setor:\", code_tract_char,\n      \"&lt;br&gt;Domic. improvisados:\", round(prop_improvisados, 2), \"%\",\n      \"&lt;br&gt;Total domicílios:\", cn22_dom01_ocu_tot_1\n    ) %&gt;% lapply(htmltools::HTML)\n  ) %&gt;%\n  addLegend(\n    pal = pal_improvisados,\n    values = ~prop_improvisados,\n    opacity = 0.8,\n    title = \"% Improvisados\",\n    position = \"bottomright\",\n    labFormat = labelFormat(suffix = \"%\", digits = 2)\n  ) %&gt;%\n  addControl(\n    paste(nome_mun, \"- Domicílios Improvisados\"),\n    position = \"topright\"\n  )\n\nmapa_improvisados"
  },
  {
    "objectID": "03-city-maps-example.html#mapas-estáticos-para-exportação",
    "href": "03-city-maps-example.html#mapas-estáticos-para-exportação",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Criar mapas estáticos com ggplot2\nif (all(st_geometry_type(dados_mapa) %in% c(\"POLYGON\", \"MULTIPOLYGON\"))) {\n  # Mapa 1: Proporção de casas\n  mapa_estatico1 &lt;- ggplot(dados_mapa) +\n    geom_sf(aes(fill = prop_casas), color = NA, size = 0.1) +\n    scale_fill_viridis(\n      name = \"% Casas\",\n      option = \"plasma\",\n      na.value = \"gray90\",\n      labels = scales::percent_format(scale = 1)\n    ) +\n    labs(\n      title = paste(\"Proporção de Domicílios tipo Casa -\", nome_mun),\n      subtitle = \"Por setor censitário - Censo 2022\",\n      caption = \"Fonte: IBGE - Censo Demográfico 2022\"\n    ) +\n    theme_void() +\n    theme(\n      plot.title = element_text(hjust = 0.5, face = \"bold\", size = 14),\n      legend.position = \"bottom\",\n      legend.key.width = unit(2, \"cm\")\n    )\n  \n  print(mapa_estatico1)\n  \n  # Mapa 2: Domicílios improvisados\n  if (nrow(dados_improvisados) &gt; 0) {\n    mapa_estatico2 &lt;- ggplot(dados_improvisados) +\n      geom_sf(aes(fill = prop_improvisados), color = NA, size = 0.1) +\n      scale_fill_gradientn(\n        name = \"% Improvisados\",\n        colors = c(\"lightyellow\", \"orange\", \"red\", \"darkred\"),\n        na.value = \"gray90\",\n        limits = c(0, max(dados_improvisados$prop_improvisados, na.rm = TRUE)),\n        labels = scales::percent_format(scale = 1, accuracy = 0.1)\n      ) +\n      labs(\n        title = paste(\"Domicílios Improvisados -\", nome_mun),\n        subtitle = \"Por setor censitário - Censo 2022\",\n        caption = \"Fonte: IBGE - Censo Demográfico 2022\"\n      ) +\n      theme_void() +\n      theme(\n        plot.title = element_text(hjust = 0.5, face = \"bold\", size = 14),\n        legend.position = \"bottom\",\n        legend.key.width = unit(2, \"cm\")\n      )\n    \n    print(mapa_estatico2)\n  }\n}"
  },
  {
    "objectID": "03-city-maps-example.html#análise-por-bairrodistrito",
    "href": "03-city-maps-example.html#análise-por-bairrodistrito",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Agregar indicadores por bairro (se disponível)\nif (\"nome_bairro\" %in% names(indicadores_mun)) {\n  bairros_agg &lt;- indicadores_mun %&gt;%\n    group_by(cod_bairro, nome_bairro) %&gt;%\n    summarise(\n      n_setores = n(),\n      media_casas = mean(cn22_dom03_cas_tot_2 * 100, na.rm = TRUE),\n      media_aptos = mean(cn22_dom03_apt_tot_2 * 100, na.rm = TRUE),\n      media_improvisados = mean(cn22_dom02_dpio_tot_2 * 100, na.rm = TRUE),\n      media_densidade = mean(cn22_dom03_6mor_tot_2 * 100, na.rm = TRUE),\n      .groups = 'drop'\n    ) %&gt;%\n    arrange(desc(media_improvisados))\n  \n  # Gráfico de ranking\n  top_bairros &lt;- bairros_agg %&gt;%\n    filter(!is.na(nome_bairro) & nome_bairro != \"\") %&gt;%\n    arrange(desc(media_improvisados)) %&gt;%\n    head(15)\n  \n  if (nrow(top_bairros) &gt; 0) {\n    ggplot(top_bairros, \n           aes(x = reorder(nome_bairro, media_improvisados), \n               y = media_improvisados)) +\n      geom_col(fill = \"steelblue\", alpha = 0.8) +\n      geom_text(aes(label = round(media_improvisados, 2)), \n                hjust = -0.2, size = 3) +\n      coord_flip() +\n      labs(\n        title = paste(\"Top 15 Bairros com Mais Domicílios Improvisados -\", nome_mun),\n        x = \"Bairro\",\n        y = \"% de Domicílios Improvisados\"\n      ) +\n      theme_minimal() +\n      theme(\n        plot.title = element_text(face = \"bold\"),\n        axis.text.y = element_text(size = 9)\n      )\n  }\n}"
  },
  {
    "objectID": "03-city-maps-example.html#tabela-interativa-de-indicadores",
    "href": "03-city-maps-example.html#tabela-interativa-de-indicadores",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Criar tabela resumo para os primeiros 50 setores\ntabela_resumo &lt;- setores_com_info %&gt;%\n  st_drop_geometry() %&gt;%\n  select(\n    Setor = code_tract_char,\n    Bairro = nome_bairro,\n    `Casas (%)` = cn22_dom03_cas_tot_2,\n    `Aptos (%)` = cn22_dom03_apt_tot_2,\n    `Improvisados (%)` = cn22_dom02_dpio_tot_2,\n    `&gt;6 Moradores (%)` = cn22_dom03_6mor_tot_2,\n    `Total Domicílios` = cn22_dom01_ocu_tot_1\n  ) %&gt;%\n  mutate(\n    across(where(is.numeric) & contains(\"%\"), ~ round(.x * 100, 2)),\n    across(where(is.numeric) & !contains(\"%\"), ~ round(.x, 0))\n  ) %&gt;%\n  head(50)  # Limitar para performance\n\n# Tabela interativa com DT\ndatatable(\n  tabela_resumo,\n  options = list(\n    pageLength = 10,\n    dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel'),\n    scrollX = TRUE\n  ),\n  caption = paste(\"Indicadores Domiciliares - Primeiros 50 Setores -\", nome_mun),\n  rownames = FALSE,\n  filter = 'top'\n) %&gt;%\n  formatStyle(\n    'Improvisados (%)',\n    background = styleColorBar(tabela_resumo$`Improvisados (%)`, 'lightcoral'),\n    backgroundSize = '100% 90%',\n    backgroundRepeat = 'no-repeat'\n  ) %&gt;%\n  formatStyle(\n    'Casas (%)',\n    background = styleColorBar(tabela_resumo$`Casas (%)`, 'lightblue'),\n    backgroundSize = '100% 90%'\n  )"
  },
  {
    "objectID": "03-city-maps-example.html#resumo-estatístico",
    "href": "03-city-maps-example.html#resumo-estatístico",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "# Calcular estatísticas descritivas\nresumo_estatistico &lt;- indicadores_mun %&gt;%\n  summarise(\n    `Total Setores` = n(),\n    `Média Casas (%)` = mean(cn22_dom03_cas_tot_2 * 100, na.rm = TRUE),\n    `Média Aptos (%)` = mean(cn22_dom03_apt_tot_2 * 100, na.rm = TRUE),\n    `Média Improvisados (%)` = mean(cn22_dom02_dpio_tot_2 * 100, na.rm = TRUE),\n    `Média &gt;6 Moradores (%)` = mean(cn22_dom03_6mor_tot_2 * 100, na.rm = TRUE),\n    `Total Domicílios` = sum(cn22_dom01_ocu_tot_1, na.rm = TRUE),\n    `Total Moradores` = sum(cn22_dom01_ocu_tot_mor_1, na.rm = TRUE)\n  ) %&gt;%\n  mutate(across(where(is.numeric), ~ round(.x, 2)))\n\ncat(\"RESUMO ESTATÍSTICO -\", nome_mun, \"\\n\")\n\nRESUMO ESTATÍSTICO - São Paulo \n\ncat(\"================================\\n\")\n\n================================\n\nprint(resumo_estatistico)\n\n# A tibble: 1 × 7\n  `Total Setores` `Média Casas (%)` `Média Aptos (%)` `Média Improvisados (%)`\n            &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;                    &lt;dbl&gt;\n1           27301              63.6              35.4                     0.14\n# ℹ 3 more variables: `Média &gt;6 Moradores (%)` &lt;dbl&gt;, `Total Domicílios` &lt;dbl&gt;,\n#   `Total Moradores` &lt;dbl&gt;"
  },
  {
    "objectID": "03-city-maps-example.html#como-usar-para-outros-municípios",
    "href": "03-city-maps-example.html#como-usar-para-outros-municípios",
    "title": "Mapas - São Paulo/SP",
    "section": "",
    "text": "Para gerar mapas para outro município, renderize com parâmetros diferentes:\n# Rio de Janeiro\nquarto render 03-mapa-cidades.qmd -P cod_mun:3304557 -P nome_mun:\"Rio de Janeiro\"\n\n# Belo Horizonte\nquarto render 03-mapa-cidades.qmd -P cod_mun:3106200 -P nome_mun:\"Belo Horizonte\"\n\n# Curitiba\nquarto render 03-mapa-cidades.qmd -P cod_mun:4106902 -P nome_mun:\"Curitiba\"\nPróximos passos: 1. Execute 01-import-data.qmd para baixar os dados 2. Execute 02-gerar-indicadores.qmd para calcular indicadores\n3. Execute este documento para gerar os mapas 4. Para publicar: quarto render e suba a pasta docs/ para GitHub Pages\n\nDocumento gerado em 07/01/2026 19:31"
  }
]