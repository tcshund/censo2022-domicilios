[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dados de Domicílios",
    "section": "",
    "text": "Este projeto processa e analisa os microdados do Censo Demográfico 2022.\n\nEstrutura\n\n01-import-data.qmd - Pipeline completo de download e conversão dos dados do IBGE\n02-indicators.qmd - Criação dos indicadores exibidos na plataforma GeoReDUS\ndata/ - Dados brutos e processados\nimages/ - Imagens usadas\ndocs/ - Site gerado (GitHub Pages)\n\n\n\nComo usar\n\nExecute o pipeline de importação: 01-import-data.qmd\nOs dados serão processados e organizados automaticamente"
  },
  {
    "objectID": "01-import-data.html",
    "href": "01-import-data.html",
    "title": "Import Data",
    "section": "",
    "text": "Sobre\nEste script apresenta um pipeline reproduzível para baixar, organizar, padronizar e consolidar os dados agregados referentes à dados de Domicílos do Universo do Censo Demográfico 2022 produzidos pelo Instituto Brasileiro de Geografia e Estatística - IBGE.\nO objetivo é transformar os arquivos originais, distribuídos em múltiplos conjuntos temáticos e arquivos CSV, em um conjunto integrado, limpo e eficiente de bases no formato parquet:\n\n01_basico.parquet\n02_domicilio.parquet\n\n\n\nBibliotecas\nLoad Packages\n\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(fs)\nlibrary(here)\nlibrary(httr)\nlibrary(janitor)\nlibrary(purrr)\nlibrary(readr)\nlibrary(rvest)\nlibrary(stringr)\n\n\n\nConfiguração do ambiente\nSet the Environment\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \n\npastas &lt;- c(\n  sprintf(\"%s/00_logs\", pasta_base),\n  sprintf(\"%s/01_raw\", pasta_base),\n  sprintf(\"%s/02_processed\", pasta_base)\n)\n\n# Criar pastas se ainda não existirem\nfor (pasta in pastas) {\n  dir.create(pasta, recursive = TRUE, showWarnings = FALSE)\n}\n\n# Atribuir nomes às variáveis \npasta_logs &lt;- pastas[1]  # Erros, arquivos de log\npasta_arqs &lt;- pastas[2]  # Dados brutos (zips baixados e csvs descompactados)\npasta_pqs  &lt;- pastas[3]  # Dados processados (parquets e csvs temáticos)\n\nAumentar o tempo máximo permitido para downloads:\n(padrão do R = 60s; arquivos do Censo são grandes e podem demorar mais)\n\n# getOption(\"timeout\") # Descomente para verificar o valor atual options\n(timeout = 1000) # Define novo limite (em segundos, aprox. 16 min)\n\n\n\n1. Baixar e descompactar os dados brutos\nImport\n\n1.1 Definição do link de download\nO IBGE disponibiliza os agregados por setor censitário em duas versões:\n\nXLSX: menor, mas mais lenta para carregar\nCSV: maior, porém mais leve para importar no R\n\nOptamos pela versão CSV.\n\nurl &lt;- \"https://ftp.ibge.gov.br/Censos/Censo_Demografico_2022/Agregados_por_Setores_Censitarios/Agregados_por_Setor_csv/\"\n\n\n\n1.2 Listagem dos arquivos disponíveis\n\n\n [1] \"Agregados_por_setores_alfabetizacao_BR.zip\"                      \n [2] \"Agregados_por_setores_basico_BR_20250417.zip\"                    \n [3] \"Agregados_por_setores_caracteristicas_domicilio1_BR.zip\"         \n [4] \"Agregados_por_setores_caracteristicas_domicilio2_BR_20250417.zip\"\n [5] \"Agregados_por_setores_caracteristicas_domicilio3_BR_20250417.zip\"\n [6] \"Agregados_por_setores_cor_ou_raca_BR.zip\"                        \n [7] \"Agregados_por_setores_demografia_BR.zip\"                         \n [8] \"Agregados_por_setores_domicilios_indigenas_BR.zip\"               \n [9] \"Agregados_por_setores_domicilios_quilombolas_BR.zip\"             \n[10] \"Agregados_por_setores_obitos_BR.zip\"                             \n[11] \"Agregados_por_setores_parentesco_BR.zip\"                         \n[12] \"Agregados_por_setores_pessoas_indigenas_BR.zip\"                  \n[13] \"Agregados_por_setores_pessoas_quilombolas_BR.zip\"                \n\n\nVamos selecionar apenas os arquivos “Básico” e aqueles com dados de Domicílios.\n\n\n[1] \"Agregados_por_setores_basico_BR_20250417.zip\"                    \n[2] \"Agregados_por_setores_caracteristicas_domicilio1_BR.zip\"         \n[3] \"Agregados_por_setores_caracteristicas_domicilio2_BR_20250417.zip\"\n[4] \"Agregados_por_setores_caracteristicas_domicilio3_BR_20250417.zip\"\n[5] \"Agregados_por_setores_domicilios_indigenas_BR.zip\"               \n[6] \"Agregados_por_setores_domicilios_quilombolas_BR.zip\"             \n\n\n\n\n1.3 Obter o tamanho dos arquivos a serem baixados\n\n\n179M\n\n\n\n\n1.4 Download dos arquivos\nBaixar os arquivos zips, se ainda não existirem, e salvá-los na pasta “raw”.\n\nwalk(urls, function(url) {\n  arquivo_local &lt;- file.path(pasta_arqs, basename(url))\n  \n  if (!file_exists(arquivo_local)) {\n    size_esperado &lt;- get_file_size(url)\n    resultado &lt;- try(download.file(url, arquivo_local, quiet = TRUE), silent = TRUE)\n    \n    if (inherits(resultado, \"try-error\") || \n        !file_exists(arquivo_local) || \n        (size_esperado &gt; 0 && file_size(arquivo_local) != size_esperado)) {\n      \n      cat(\"Erro no download:\", basename(url), \"\\n\")\n      \n      # Registro no log se tiver erro\n      download_error &lt;- data.frame(\n        arquivo = basename(url),\n        tipo    = \"universo_zip\",\n        stringsAsFactors = FALSE\n      )\n      \n      out_file &lt;- file.path(pasta_logs, \"erros_download_arqs.csv\")\n      write_delim(download_error, out_file, delim = \";\",\n                  append = file_exists(out_file))\n      \n      if (file_exists(arquivo_local)) file_delete(arquivo_local)\n      return()\n    }\n    cat(\"Download concluído:\", basename(url), \"\\n\")\n  } else {\n    cat(\"Arquivo já existe na pasta:\", basename(url), \"\\n\")\n  }\n})\n\n\n\n1.5 Descompactar os arquivos\nDescompactar os arquivos em formato .zip vai gerar os arquivos em .csv. O resultado é salvo na pasta “processed”.\n\nzip_files &lt;- pasta_arqs |&gt; \n        dir_ls(type = \"file\", regexp = \"\\\\.zip$\")\ncsv_files &lt;- pasta_arqs |&gt; \n        dir_ls(type = \"file\", regexp = \"\\\\.csv$\")\n\n# Se a pasta CSV já tem arquivos, pula o unzip\nif (length(csv_files) == 0) {\n  zip_files |&gt; \n        map(\\(x) unzip(x, exdir = pasta_arqs), .progress = TRUE)\n} else {\n  cat(\"Arquivos CSV já descompactados, pulando unzip...\\n\")\n}\nzip_files |&gt; file_delete() \n\n\n\n\n2. Leitura e tratamento dos dados\nTidy\nNesta etapa, os arquivos CSV descompactados são lidos, padronizados e organizados em estruturas consistentes para posterior integração.\n\n2.1 Criar função para leitura dos arquivos\nO trecho define a função abrir_csv(), que localiza todos os arquivos CSV em uma pasta usando um padrão (reg_pattern), lê todos eles como texto, concatena em um único data frame, padroniza nomes de colunas, converte para numéricas as variáveis de resultado (VXXXX), ordena pela primeira coluna (geralmente cd_setor) e devolve um objeto limpo e pronto para análise. A cada etapa, arqs_csv é atualizado, sempre substituindo o conteúdo anterior pelo novo.\n\nabrir_csv &lt;- function(reg_pattern) {\n# Localizar arquivos CSV que correspondem ao padrão informado (\"reg_pattern\")\n    arqs_csv &lt;- list.files(pasta_arqs,\n                         pattern = reg_pattern,\n                         full.names = TRUE,\n                         recursive = FALSE)   \n# Ler os CSVs como texto e transformar em df\n  arqs_csv &lt;- read_delim(arqs_csv,\n                         delim = \";\",\n                         col_types = cols(.default = \"c\"),\n                         locale = locale(encoding = \"iso_8859-1\")) %&gt;%\n    arrange(.[[1]]) # ordenar pela primeira coluna (cd_setor)\n  \n# Padronização (nomes snake_case, variáveis Vxxxx para maiúsculas (padrão oficial do IBGE)\n  arqs_csv &lt;- arqs_csv %&gt;%\n    clean_names() %&gt;%\n    rename_at(vars(matches(\"^v[0-9]{4}[0-9]?$\")), toupper) |&gt;\n    rename(cd_setor = any_of(\"setor\"))\n  \n# Tratamento especial para o arquivo \"basico\" \n  if (str_detect(reg_pattern, \"basico\")) {\n      arqs_csv &lt;- arqs_csv %&gt;%\n      mutate_at(vars\n                (matches(\"V[0-9]{3}[0-9]?$\")), \n                ~ str_replace(., ',', '.')) %&gt;%\n      mutate(area_km2 = str_replace(area_km2, ',', '.'))\n      \n    # extrair lista única de setores para uso nos parquets temáticos\n    setores &lt;- arqs_csv %&gt;% \n      select(cd_setor) %&gt;% \n      distinct()\n\n    out_file &lt;- sprintf(\"%s/00_setores.csv\", pasta_pqs) \n    write_delim(setores, out_file, delim = ';')\n  }\n  \n# Transformar valores que significam \"ausência de dado\" (X, x, . → NA)\n  arqs_csv &lt;- arqs_csv %&gt;%\n    mutate(\n        across(everything(), \n               ~ str_replace(., \"^[Xx\\\\.]$\", \n                             as.character(NA))))\n  \n# Todas as variáveis Vxxxx para numéricas\n  arqs_csv &lt;- arqs_csv %&gt;% \n    mutate_at(vars\n              (matches(\"^V[0-9]{4}[0-9]?$\")), \n              as.numeric)\n  \n  return(arqs_csv)\n}\n\n\n\n2.2 Criar função para agrupamento de arquivos temáticos\n\njuntar_temas &lt;- function(pattern_list, cod_setores) {\n  # Dataframe para agregar resultados\n  df &lt;- cod_setores\n  # para cada padrão, abrir o CSV e juntar ao df\n  for (pat in pattern_list) {\n      tmp_df &lt;- abrir_csv(pat)\n      df &lt;- left_join(df, tmp_df, by = \"cd_setor\")\n  }\n# reordenar: cd_setor primeiro, depois em ordem alfabética\n  outras &lt;- setdiff(names(df), \"cd_setor\")\n  df &lt;- df[, c(\"cd_setor\", sort(outras))]\n    \n  return(df)\n}\n\n\n\n\n3. Transformar os arquivos csvs em parquets\nTransform\nTemas: Básico e Domicílios\nPara cada grupo, faz a mesma sequência:\n\nLê os arquivos do grupo\nUsando a primeira função criada abrir_csv(\"tema\")\nOrganiza os dados por setor censitário\nUsando a segunda função criada juntar_temas().\nExporta para .parquet\nUm formato mais leve e rápido que CSV. Arquivos salvos na pasta 03_processado.\nRemove objetos da memória (rm e gc),\nNecessário porque arquivos são enormes.\n\n\n3.1 Básico\n\n# Básico\nif (!file_exists(sprintf(\"%s/01_basico.parquet\", pasta_pqs))) {\n  basico &lt;- abrir_csv(\"basico\")\n  basico &lt;- basico %&gt;% mutate(area_km2 = as.double(area_km2))\n  write_parquet(basico, sprintf(\"%s/01_basico.parquet\", pasta_pqs))\n  rm(basico); gc(T)\n  cat(\"01_basico.parquet criado\\n\")\n} else {\n  cat(\"01_basico.parquet já existe, pulando...\\n\")\n}\n\n01_basico.parquet já existe, pulando...\n\n\n\n# Exportar csv com todos os setores censitários para uso nos temas a seguir\nsetores &lt;- sprintf(\"%s/00_setores.csv\", pasta_pqs)\n\nif (file_exists(setores)) {\n  setores &lt;- read_delim(setores, delim = \";\", col_types = \"c\")\n  cat(paste0(\"CSV com setores censitários carregado (\", nrow(setores), \" setores)\\n\"))\n} else {\n  stop(\"00_setores.csv nao encontrado. Execute primeiro o bloco basico.\")\n}\n\nCSV com setores censitários carregado (468099 setores)\n\n\n\n\n3.2 Domicílios\nJunção dos cinco arquivos que contém informações sobre os domicílios.\n\n# Domicilios\nif (!file_exists(sprintf(\"%s/02_domicilio.parquet\", pasta_pqs))) {\n\n  dom_patterns &lt;- list.files(\n    pasta_arqs,\n    pattern = \"domicilio.*\\\\.csv$\",\n    full.names = FALSE\n  ) |&gt;\n    \n    str_remove(\"^Agregados_por_setores_\") |&gt;\n    str_remove(\"_BR.*\\\\.csv$\")\n\n  dom &lt;- juntar_temas(dom_patterns, cod_setores = setores)\n\n  write_parquet(dom, sprintf(\"%s/02_domicilio.parquet\", pasta_pqs))\n\n  rm(dom); gc(TRUE)\n  cat(\"02_domicilio.parquet criado\\n\")\n\n} else {\n  cat(\"02_domicilio.parquet já existe, pulando...\\n\")\n}\n\n02_domicilio.parquet já existe, pulando...\n\n\n\n\n\n4. Explorar e validar os dados\nUnderstand\n\n# Resumo dos parquets finais\npqs_files &lt;- dir_ls(pasta_pqs, regexp = \"\\\\.parquet$\")\npqs_info &lt;- map_dfr(pqs_files, ~ {\n  df &lt;- read_parquet(.x)\n  tibble(\n    arquivo = basename(.x),\n    n_setores = nrow(df), # número de setores censitários\n    n_vars = ncol(df), # número de colunas \n    tamanho_mb = file_size(.x),\n    memoria_mb = round(object.size(df) / 1024^2, 1)\n  )\n})\nprint(pqs_info)\n\n# A tibble: 2 × 5\n  arquivo              n_setores n_vars  tamanho_mb memoria_mb  \n  &lt;chr&gt;                    &lt;int&gt;  &lt;int&gt; &lt;fs::bytes&gt; &lt;objct_sz&gt;  \n1 01_basico.parquet       468099     36       11.9M 167 bytes   \n2 02_domicilio.parquet    468099   1030      144.1M 3707.1 bytes\n\n\n\nVisão geral do parquet básico\n\npqs_files |&gt; \n  keep(~ str_detect(basename(.x), \"^01_\")) |&gt;  \n  walk(~ {\n    cat(\"\\n====\", basename(.x), \"====\\n\")\n    read_parquet(.x) |&gt; \n      slice_head(n = 5) |&gt; \n      select(cd_setor, everything()) |&gt;  \n      print(n = 6)  \n  })\n\n\n==== 01_basico.parquet ====\n# A tibble: 5 × 36\n  cd_setor      situacao cd_sit cd_tipo area_km2 cd_regiao nm_regiao cd_uf nm_uf\n  &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;\n1 110001505000… Urbana   1      0          0.539 1         Norte     11    Rond…\n2 110001505000… Urbana   1      0          0.236 1         Norte     11    Rond…\n3 110001505000… Urbana   1      0          0.212 1         Norte     11    Rond…\n4 110001505000… Urbana   1      0          0.505 1         Norte     11    Rond…\n5 110001505000… Urbana   1      0          0.299 1         Norte     11    Rond…\n# ℹ 27 more variables: cd_mun &lt;chr&gt;, nm_mun &lt;chr&gt;, cd_dist &lt;chr&gt;,\n#   nm_dist &lt;chr&gt;, cd_subdist &lt;chr&gt;, nm_subdist &lt;chr&gt;, cd_bairro &lt;chr&gt;,\n#   nm_bairro &lt;chr&gt;, cd_nu &lt;chr&gt;, nm_nu &lt;chr&gt;, cd_fcu &lt;chr&gt;, nm_fcu &lt;chr&gt;,\n#   cd_aglom &lt;chr&gt;, nm_aglom &lt;chr&gt;, cd_rgint &lt;chr&gt;, nm_rgint &lt;chr&gt;,\n#   cd_rgi &lt;chr&gt;, nm_rgi &lt;chr&gt;, cd_concurb &lt;chr&gt;, nm_concurb &lt;chr&gt;,\n#   V0001 &lt;dbl&gt;, V0002 &lt;dbl&gt;, V0003 &lt;dbl&gt;, V0004 &lt;dbl&gt;, V0005 &lt;dbl&gt;,\n#   V0006 &lt;dbl&gt;, V0007 &lt;dbl&gt;\n\n\n\n\nVisão geral do parquet domicílios\n\npqs_files |&gt; \n  keep(~ str_detect(basename(.x), \"^02_\")) |&gt;  \n  walk(~ {\n    cat(\"\\n====\", basename(.x), \"====\\n\")\n    read_parquet(.x) |&gt; \n      slice_head(n = 5) |&gt; \n      select(cd_setor, everything()) |&gt;  \n      print(n = 6)  \n  })\n\n\n==== 02_domicilio.parquet ====\n# A tibble: 5 × 1,030\n  cd_setor V00001 V00002 V00003 V00004 V00005 V00006 V00007 V00008 V00009 V00010\n  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 1100015…    336      0      0    336    928      0      0    136      0      0\n2 1100015…    208      0      0    208    556      0      0     73      0      0\n3 1100015…     85      0      0     85    222      0      0     24      0      0\n4 1100015…    281     NA      0    281    783     NA      0    124      0      0\n5 1100015…    291      0      0    291    748      0      0    102      0      0\n# ℹ 1,019 more variables: V00011 &lt;dbl&gt;, V00012 &lt;dbl&gt;, V00013 &lt;dbl&gt;,\n#   V00014 &lt;dbl&gt;, V00015 &lt;dbl&gt;, V00016 &lt;dbl&gt;, V00017 &lt;dbl&gt;, V00018 &lt;dbl&gt;,\n#   V00019 &lt;dbl&gt;, V00020 &lt;dbl&gt;, V00021 &lt;dbl&gt;, V00022 &lt;dbl&gt;, V00023 &lt;dbl&gt;,\n#   V00024 &lt;dbl&gt;, V00025 &lt;dbl&gt;, V00026 &lt;dbl&gt;, V00027 &lt;dbl&gt;, V00028 &lt;dbl&gt;,\n#   V00029 &lt;dbl&gt;, V00030 &lt;dbl&gt;, V00031 &lt;dbl&gt;, V00032 &lt;dbl&gt;, V00033 &lt;dbl&gt;,\n#   V00034 &lt;dbl&gt;, V00035 &lt;dbl&gt;, V00036 &lt;dbl&gt;, V00037 &lt;dbl&gt;, V00038 &lt;dbl&gt;,\n#   V00039 &lt;dbl&gt;, V00040 &lt;dbl&gt;, V00041 &lt;dbl&gt;, V00042 &lt;dbl&gt;, V00043 &lt;dbl&gt;, …"
  },
  {
    "objectID": "02-indicators.html",
    "href": "02-indicators.html",
    "title": "Indicators",
    "section": "",
    "text": "Sobre\nEste script constrói um conjunto de indicadores relacionados ao tema Domicílios, a partir dos dados do Censo Demográfico do IBGE de 2022, para exibição na plataforma GeoReDUS. Os indicadores são calculados para todos os setores censitários do Brasil.\nOs indicadores produzidos abrangem os seguintes eixos:\n\nOcupação de Domicílios\nDados de domicílios particulares e coletivos ocupados e seus moradores.\nPosse de Domicílios\nDentre os domicílios ocupados, indicadores que abrangem os particulares permanentes e improvisados e seus moradores com recortes de sexo.\nDados de Domicílios Particulares\nDentre os domicílios particulares, recortes de tipo de residência (casas, apartamentos) e de seus moradores, além de domicílios com mais de 6 moradores.\n\nAo final, os resultados são organizados e exportados em arquivos CSV, que servem como base para análises e visualizações posteriores. Os indicadores seguem uma nomenclatura padronizada, que explicita o tema, o subtema, o recorte, a variante e o tipo de dado, permitindo a identificação direta do conteúdo de cada variável.\n\n\nBibliotecas\nLoad Packages\n\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(fs)\nlibrary(here)\nlibrary(readr)\nlibrary(tidyr)  \n\n\n\n1. Configuração do ambiente\nSet the Environment\n\n# Definição da estrutura de pastas para organizar os dados \npasta_base &lt;- here(\"data\") \npasta_pqs &lt;- sprintf(\"%s/02_processed\", pasta_base)\n\n# Criação da pasta para salvar os csvs com os indicadores\npasta_out &lt;- sprintf(\"%s/03_indicators\", pasta_base)\ndir.create(pasta_out, recursive = TRUE, showWarnings = FALSE)\n\n\n\n2. Nomenclatura adotada\n\nIndicadores de Domicílios\n\n\n\n\n\n\n\n\n\nTema\nSubtema\nST\nDescrição\nIndicador/Variável\n\n\n\n\ndom01\nOcupação\nocu\nDomicilios Ocupados\ndom01_ocu\n\n\ndom02\nPosse\ndppo\nDomicílios Particulares Permanentes Ocupados\ndom02_dppo\n\n\ndom02\nPosse\ndpio\nDomicílios Particulares Improvisados Ocupados\ndom02_dpio\n\n\ndom02\nPosse\ndccm\nDomicílios Coletivos Com Morador\ndom02_dccm\n\n\ndom03\nParticulares\ncas\nTipo de DPPO: Casas\ndom03_cas\n\n\ndom03\nParticulares\napt\nTipo de DPPO: Apartamentos\ndom03_apt\n\n\ndom03\nParticulares\n6mor\nDPPO com mais de 6 moradores\ndom03_6mor\n\n\n\n\nRecortes\n\n\nSigla\nRecorte\n\n\n\n\ntot\nTotal\n\n\ncor\nCor ou Raça\n\n\nsex\nSexo\n\n\ncorsex\nCor + Sexo\n\n\n\n\nVariantes\n\n\nSigla\nVariante\n\n\n\n\nmor\nMoradores\n\n\nf\nSexo Feminino\n\n\nm\nSexo Masculino\n\n\nama\nPessoas Amarelas\n\n\nbra\nPessoas Brancas\n\n\nind\nPessoas Indígenas\n\n\nneg\nPessoas Negras (Pretas + Pardas)\n\n\n\n\nTipo de dado\n\n\nTipo\nDescrição\n\n\n\n\n0\nDado bruto, usa diretamente a variável do IBGE (ex. V00001)\n\n\n1\nDado composto, faz soma ou subtração de variáveis do IBGE\n\n\n2\nPorcentagem (%), divide variáveis do IBGE\n\n\n\n\n\n3. Leitura dos parquets\nO fluxo deste script parte sempre dos arquivos em formato parquet, que funcionam como a fonte de dados original e nunca são modificados diretamente.\nA leitura dos parquets carrega os dados em memória como tibbles, sobre os quais aplicamos transformações com mutate(), filter(), group_by(), summarise() e outras funções do dplyr. Essas operações criam colunas temporárias, fazem cálculos e reorganizam informações, mas tudo permanece apenas no objeto resultante em memória.\nAo longo do fluxo, esses objetos transformados podem ser encadeados ou substituídos, mas não são gravados automaticamente em nenhum arquivo. Apenas na etapa final do script os resultados são efetivamentente salvos e exportados como CSVs.\n\n\n4. Criação e transformação das variáveis\nCom os dados já carregados, o script aplica operações do dplyr.\nCada linha indica uma nova coluna derivada.\n\nbasico &lt;- read_parquet(\n  sprintf(\"%s/01_basico.parquet\", pasta_pqs))\n\ndomicilios &lt;- read_parquet(\n  sprintf(\"%s/02_domicilio.parquet\", pasta_pqs)) %&gt;%\n  replace(is.na(.), 0) %&gt;%\n  mutate(\n      # # # Indicadores Absolutos\n      # dom01 - Ocupação \n      # total de domicílios (dppo+dpio+dccm) \n      dom01_ocu_tot_1 = V00001 + V00002 + V00003, \n      # total de moradores (em dppo+dpio+dccm)\n      dom01_ocu_tot_mor_1 = V00005 + V00006 + V00007,\n      \n      # dom02 - Posse (apenas ocupados)\n      # domicílios particulares \n      dom02_dppo_tot_0 = V00001, \n      # moradores em dom particulares (V00011 + V00014)\n      dom02_dppo_tot_mor_0 = V00005, \n      dom02_dppo_sex_m_0 = V00011,\n      dom02_dppo_sex_f_0 = V00014,\n      dom02_dpio_tot_0 = V00002, # improvisados\n      \n      # dom03 - Domicílios Particulares\n      # Casas\n      dom03_cas_tot_1 = V00047 + V00048, \n      dom03_cas_tot_mor_1 = V00084 + V00085,\n      dom03_cas_sex_m_1 = V00502 + V00503,\n      dom03_cas_sex_f_1 = V00505 + V00506,\n      # Apartamentos\n      dom03_apt_tot_0 = V00049,\n      dom03_apt_tot_mor_0 = V00086,\n      dom03_apt_sex_m_0 = V00504,\n      dom03_apt_sex_f_0 = V00507,\n      # Domicílios com mais de 6 moradores\n      dom03_6mor_tot_1 =  V00022 + V00023 + V00024 + V00025 + V00026\n  ) %&gt;%\n  mutate(\n    # # # Indicadores Relativos\n    # dom02 - Posse, em relação ao total de ocupados\n    dom02_dppo_tot_2 = dom02_dppo_tot_0 / dom01_ocu_tot_1,\n    dom02_dppo_tot_mor_2 = dom02_dppo_tot_mor_0 / dom01_ocu_tot_mor_1,\n    dom02_dppo_sex_f_2 = dom02_dppo_sex_f_0 / dom02_dppo_tot_mor_0,\n    dom02_dppo_sex_m_2 = dom02_dppo_sex_m_0 / dom02_dppo_tot_mor_0,  \n    dom02_dpio_tot_2 = dom02_dpio_tot_0 / dom01_ocu_tot_1,\n    \n    # dom03 - Domicílios Particulares \n    # Casas\n    dom03_cas_tot_2 = dom03_cas_tot_1 / dom02_dppo_tot_0,\n    dom03_cas_tot_mor_2 = dom03_cas_tot_mor_1 / dom02_dppo_tot_mor_0,\n    dom03_cas_sex_m_2 = dom03_cas_sex_m_1 / dom02_dppo_sex_m_0,\n    dom03_cas_sex_f_2 = dom03_cas_sex_f_1 / dom02_dppo_sex_f_0,\n    # Apartamentos\n    dom03_apt_tot_2 = dom03_apt_tot_0 / dom02_dppo_tot_0,\n    dom03_apt_tot_mor_2 = dom03_apt_tot_mor_0 / dom02_dppo_tot_mor_0,\n    dom03_apt_sex_m_2 = dom03_apt_sex_m_0 / dom02_dppo_sex_m_0,  \n    dom03_apt_sex_f_2 = dom03_apt_sex_f_0 / dom02_dppo_sex_f_0,\n    # Domicílios com mais de 6 moradores\n    dom03_6mor_tot_2 = dom03_6mor_tot_1 / dom02_dppo_tot_0    \n  ) %&gt;%\n  \n  select(matches(\"^(cd|dom)\"))%&gt;%\n\n  # Inclui \"cn22\" antes de cada um dos indicadores\n  rename_with(\n  ~ paste0(\"cn22_\", .x),\n  starts_with(\"dom\")\n  ) \n\n\n\n5. Exportando os indicadores de Domicílio\nAs colunas criadas são unidas em novos csvs:\n\ncn22dom &lt;- basico %&gt;%\n  left_join(domicilios, by=\"cd_setor\") %&gt;% \n  rename(\n    cod_setor = cd_setor,\n    cod_bairro = cd_bairro,\n    cod_distrito = cd_dist,\n    cod_subdistrito = cd_subdist,\n    cod_municipio = cd_mun,\n    situacao_setor = situacao,\n    cod_uf = cd_uf,\n    nome_bairro = nm_bairro,\n    nome_distrito = nm_dist,\n    nome_municipio = nm_mun,\n    nome_subdistrito = nm_subdist,\n    nome_uf = nm_uf\n  )\n\nid_cols &lt;- c(\n  \"cod_setor\",\"cod_bairro\",\"cod_distrito\",\"cod_subdistrito\",\"cod_municipio\",\n  \"situacao_setor\",\"cod_uf\",\n  \"nome_bairro\",\"nome_distrito\",\"nome_municipio\",\"nome_subdistrito\",\"nome_uf\"\n)\n# Exportar as variáveis absolutas (brutas ou compostas)\ncn22dom_abs &lt;- cn22dom %&gt;%  \n  select(\n    all_of(id_cols),\n    ends_with(\"_0\"),\n    ends_with(\"_1\")\n  )\n\ncn22dom_abs %&gt;%\n  write_csv(sprintf(\"%s/cn22dom_abs.csv\", pasta_out))\n\n# Exportar as variáveis relativas (porcentagens)\ncn22dom_rel = cn22dom %&gt;%\n  select(\n    all_of(id_cols),\n    ends_with(\"_2\")\n  )\n\ncn22dom_rel %&gt;%\n  write_csv(sprintf(\"%s/cn22dom_rel.csv\", pasta_out))\n\n\n\n6. Verificação dos indicadores exportados\n\n6.1 Variáveis Absolutas\nOlhar geral no csv:\n\nglimpse(cn22dom_abs)\n\nRows: 468,099\nColumns: 28\n$ cod_setor                 &lt;chr&gt; \"110001505000002\", \"110001505000003\", \"11000…\n$ cod_bairro                &lt;chr&gt; \"1100015006\", \"1100015006\", \"1100015005\", \"1…\n$ cod_distrito              &lt;chr&gt; \"110001505\", \"110001505\", \"110001505\", \"1100…\n$ cod_subdistrito           &lt;chr&gt; \"11000150500\", \"11000150500\", \"11000150500\",…\n$ cod_municipio             &lt;chr&gt; \"1100015\", \"1100015\", \"1100015\", \"1100015\", …\n$ situacao_setor            &lt;chr&gt; \"Urbana\", \"Urbana\", \"Urbana\", \"Urbana\", \"Urb…\n$ cod_uf                    &lt;chr&gt; \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"1…\n$ nome_bairro               &lt;chr&gt; \"Redondo\", \"Redondo\", \"Princesa Isabel\", \"Pr…\n$ nome_distrito             &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oe…\n$ nome_municipio            &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oe…\n$ nome_subdistrito          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ nome_uf                   &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rondônia\", \"Rondôni…\n$ cn22_dom02_dppo_tot_0     &lt;dbl&gt; 336, 208, 85, 281, 291, 234, 329, 291, 100, …\n$ cn22_dom02_dppo_tot_mor_0 &lt;dbl&gt; 928, 556, 222, 783, 748, 631, 884, 762, 267,…\n$ cn22_dom02_dppo_sex_m_0   &lt;dbl&gt; 428, 270, 108, 407, 373, 296, 403, 361, 141,…\n$ cn22_dom02_dppo_sex_f_0   &lt;dbl&gt; 500, 286, 114, 376, 375, 335, 481, 401, 126,…\n$ cn22_dom02_dpio_tot_0     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ cn22_dom03_apt_tot_0      &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0,…\n$ cn22_dom03_apt_tot_mor_0  &lt;dbl&gt; 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 7, 0, 0, 0, 0,…\n$ cn22_dom03_apt_sex_m_0    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ cn22_dom03_apt_sex_f_0    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0,…\n$ cn22_dom01_ocu_tot_1      &lt;dbl&gt; 336, 208, 85, 281, 291, 234, 329, 291, 100, …\n$ cn22_dom01_ocu_tot_mor_1  &lt;dbl&gt; 928, 556, 222, 783, 748, 631, 884, 762, 267,…\n$ cn22_dom03_cas_tot_1      &lt;dbl&gt; 335, 208, 85, 280, 291, 234, 328, 291, 100, …\n$ cn22_dom03_cas_tot_mor_1  &lt;dbl&gt; 926, 556, 222, 780, 748, 631, 882, 762, 267,…\n$ cn22_dom03_cas_sex_m_1    &lt;dbl&gt; 427, 270, 108, 405, 373, 296, 402, 361, 141,…\n$ cn22_dom03_cas_sex_f_1    &lt;dbl&gt; 499, 286, 114, 375, 375, 335, 480, 401, 126,…\n$ cn22_dom03_6mor_tot_1     &lt;dbl&gt; 8, 3, 0, 15, 0, 0, 0, 4, 0, 0, 5, 3, 3, 0, 4…\n\n\nPresença das 12 colunas de identificação do arquivo básico:\n\nid_presentes_abs &lt;- sum(id_cols %in% names(cn22dom_abs)) \ncat(\"- Absolutos:\", id_presentes_abs, \"/\", length(id_cols), \"IDs OK\\n\")\n\n- Absolutos: 12 / 12 IDs OK\n\n\nIntegridade dos dados numéricos:\n\n\n- Dados absolutos:  OK \n\n\nVerificar dados aleatórios das variáveis absolutas de um município:\n\n# substitua pelo municipio que desejar \nmunicipio_escolhido &lt;- \"Goiânia\"   \n\nprint(\n  cn22dom_abs %&gt;%\n  filter(nome_municipio == municipio_escolhido) %&gt;%     \n  slice_sample(n = 10) %&gt;%     \n  # substitua \"dom01\" pelo indicador que deseja verificar     \n  # substitua \"tot\" pelo recorte que deseja verificar     \n    select(cod_setor, matches(\"dom01.*tot\")),    \n    width = Inf \n  )\n\n# A tibble: 10 × 3\n   cod_setor       cn22_dom01_ocu_tot_1 cn22_dom01_ocu_tot_mor_1\n   &lt;chr&gt;                          &lt;dbl&gt;                    &lt;dbl&gt;\n 1 520870705020016                  167                      333\n 2 520870705520036                   45                      134\n 3 520870705220006                  324                      730\n 4 520870705630034                  183                      623\n 5 520870705060009                  108                      265\n 6 520870705010012                  202                      403\n 7 520870705330074                  245                      685\n 8 520870705120016                  259                      648\n 9 520870705410003                  219                      586\n10 520870705450001                  332                      946\n\n\n\n\n6.1 Variáveis Relativas\nOlhar geral no csv:\n\nglimpse(cn22dom_rel)\n\nRows: 468,099\nColumns: 26\n$ cod_setor                 &lt;chr&gt; \"110001505000002\", \"110001505000003\", \"11000…\n$ cod_bairro                &lt;chr&gt; \"1100015006\", \"1100015006\", \"1100015005\", \"1…\n$ cod_distrito              &lt;chr&gt; \"110001505\", \"110001505\", \"110001505\", \"1100…\n$ cod_subdistrito           &lt;chr&gt; \"11000150500\", \"11000150500\", \"11000150500\",…\n$ cod_municipio             &lt;chr&gt; \"1100015\", \"1100015\", \"1100015\", \"1100015\", …\n$ situacao_setor            &lt;chr&gt; \"Urbana\", \"Urbana\", \"Urbana\", \"Urbana\", \"Urb…\n$ cod_uf                    &lt;chr&gt; \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"1…\n$ nome_bairro               &lt;chr&gt; \"Redondo\", \"Redondo\", \"Princesa Isabel\", \"Pr…\n$ nome_distrito             &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oe…\n$ nome_municipio            &lt;chr&gt; \"Alta Floresta D'Oeste\", \"Alta Floresta D'Oe…\n$ nome_subdistrito          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ nome_uf                   &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rondônia\", \"Rondôni…\n$ cn22_dom02_dppo_tot_2     &lt;dbl&gt; 1.000000, 1.000000, 1.000000, 1.000000, 1.00…\n$ cn22_dom02_dppo_tot_mor_2 &lt;dbl&gt; 1.0000000, 1.0000000, 1.0000000, 1.0000000, …\n$ cn22_dom02_dppo_sex_f_2   &lt;dbl&gt; 0.5387931, 0.5143885, 0.5135135, 0.4802043, …\n$ cn22_dom02_dppo_sex_m_2   &lt;dbl&gt; 0.4612069, 0.4856115, 0.4864865, 0.5197957, …\n$ cn22_dom02_dpio_tot_2     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ cn22_dom03_cas_tot_2      &lt;dbl&gt; 0.9970238, 1.0000000, 1.0000000, 0.9964413, …\n$ cn22_dom03_cas_tot_mor_2  &lt;dbl&gt; 0.9978448, 1.0000000, 1.0000000, 0.9961686, …\n$ cn22_dom03_cas_sex_m_2    &lt;dbl&gt; 0.9976636, 1.0000000, 1.0000000, 0.9950860, …\n$ cn22_dom03_cas_sex_f_2    &lt;dbl&gt; 0.9980000, 1.0000000, 1.0000000, 0.9973404, …\n$ cn22_dom03_apt_tot_2      &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.000000…\n$ cn22_dom03_apt_tot_mor_2  &lt;dbl&gt; 0.000000000, 0.000000000, 0.000000000, 0.003…\n$ cn22_dom03_apt_sex_m_2    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ cn22_dom03_apt_sex_f_2    &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.000000…\n$ cn22_dom03_6mor_tot_2     &lt;dbl&gt; 0.02380952, 0.01442308, 0.00000000, 0.053380…\n\n\nPresença das 12 colunas de identificação do arquivo básico:\n\n\n- Relativos:  12 / 12 IDs OK\n\n\nIntegridade dos dados numéricos:\n\nvars_rel &lt;- names(cn22dom_rel)[!names(cn22dom_rel) %in% id_cols]\n\nconta_problemas &lt;- function(x){   \n  c(     \n    \"NA\"     = sum(is.na(x) & !is.nan(x)),  # NA puro\n    \"NaN\"    = sum(is.nan(x)),               # NaN     \n    \"Inf\"    = sum(is.infinite(x) & x &gt; 0),  # +Inf     \n    \"NegInf\" = sum(is.infinite(x) & x &lt; 0)   # -Inf   \n    ) \n  }  \n\nproblemas_tipo &lt;- t(sapply(cn22dom_rel[vars_rel], conta_problemas))  \n\nproblemas_tipo\n\n                          NA   NaN Inf NegInf\ncn22_dom02_dppo_tot_2      0 18011   0      0\ncn22_dom02_dppo_tot_mor_2  0 18011   0      0\ncn22_dom02_dppo_sex_f_2    0 18011   0      0\ncn22_dom02_dppo_sex_m_2    0 18011   0      0\ncn22_dom02_dpio_tot_2      0 18011   0      0\ncn22_dom03_cas_tot_2       0 18011   0      0\ncn22_dom03_cas_tot_mor_2   0 18011   0      0\ncn22_dom03_cas_sex_m_2     0 18019   0      0\ncn22_dom03_cas_sex_f_2     0 18067   0      0\ncn22_dom03_apt_tot_2       0 18011   0      0\ncn22_dom03_apt_tot_mor_2   0 18011   0      0\ncn22_dom03_apt_sex_m_2     0 18019   0      0\ncn22_dom03_apt_sex_f_2     0 18067   0      0\ncn22_dom03_6mor_tot_2      0 18011   0      0"
  }
]